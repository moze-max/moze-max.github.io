<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hello</title>
    <url>/2024/02/23/hello/</url>
    <content><![CDATA[<h3 id="very-nice-to-see-you"><a class="markdownIt-Anchor" href="#very-nice-to-see-you"></a> very nice to see you!</h3>
<p>你一定不会相信我为了搞这个花费了多少的时间，犯了多少错误，但是不管怎么说，最终还是上线了……  <br><br />
说起来是十分的羞耻，我原本想要使用最原始的方式，那就是不用主题，不用别人写好的文件，而是完全靠自己。<br></p>
<span id="more"></span>
<p>靠自己写一个识别md文件的程序<br><br />
然后自己写一个对应的html文件，然后这个写好的js文件就会自动将md文件修改成html文件。</p>
<p>你可能会觉得好像很厉害的样子，其实不是的。<br></p>
<p>要实现这个其实非常简单.</p>
<blockquote>
<p>只需要用html用一行代码来写一个块用来接受js处理之后的值,<br><br />
然后在js中使用四行代码写一个处理md文件的程序就可以了.<br></p>
</blockquote>
<p>确实非常简单是吧?但是现在问题来了,在本地上是没法读取md文件的,这是由于浏览器的安全设置导致的.<br></p>
<p>我在网上找资料,有人给建议说:把程序部署到服务器上即可,在服务器上就没有这个安全限制了.</p>
<p>然后我把网页部署在github pages上,可是在github上我依旧没法使用JavaScript的库读取md文件.<br></p>
<p>这又是怎么一回事呢?github pages难道不是服务器?难道是有什么文件或者某些代码写错了?</p>
<p>我十分不理解,但是不知道怎么应该修复这个问题,<br>英文世界的文档有点难以找寻,一来是不知道应该怎么搜索,二来是即使搜索到了也很可能没有留意到而略过.<br></p>
<p>这个就是最大的困难了,假如无法解决这个问题,难道你要写一篇blog就要自己编辑一个html文件么?那么多浪费时间,多浪费精力啊!</p>
<blockquote>
<p>尽管html要比markdown强大得多,但是作为一个博客能用上那么强大的功能吗?为了这些用不上的强大要付出那么多的精力,实在是不划算.<br />
<br></p>
</blockquote>
<p>于是我最终决定使用主题,偶然间看见了这个开源主题.</p>
<p>其实这个主题的样式与我原本的设想已经相差甚远,但是想要找到一个完整的,崭新的,开源的,现代的主题是一件很难的事.<br></p>
<p>比如说:有的人的主题已经被他自己使用过,有很多深入定制的内容.<br>想要清理干净着实是一件难事.</p>
<p>这一个主题,作者没有更改原文件–并不是作者自己不用,而是他在另外一个bush中使用,那么现在的master就不会被他的使用所污染.</p>
<p>所以…就先这么用着吧,假如你有足够的实力,那么自定义一个主题,自行修改这个主题也不再是什么问题.</p>
<p>我曾经在知乎上看见一个答主,他也曾经对写博客很感兴趣,但是她又觉得市面上的博客软件以及主题不符合他的心意,最终,他自己写了一个博客系统.</p>
<p>开源|分享|免费|独立</p>
<blockquote>
<p>这个就是互联网精神.</p>
</blockquote>
<p>-我的Bilibili<span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vNDQxMzE4NTIz" title="欢迎您！">墨泽moozy<i class="fa fa-external-link-alt"></i></span></p>
<p>-我的公众号<a href="#hellomoozy">墨泽moozy</a></p>
<p>-我的知乎<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9nYW4tZ2FuLWppbmctamluZy01MS05MA==" title="欢迎关注">干干净净我的心<i class="fa fa-external-link-alt"></i></span></p>
<p>-我的<span class="exturl" data-url="aHR0cHM6Ly9tb3plLW1heC5naXRodWIuaW8=" title="欢迎到访！">博客<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>text</tag>
      </tags>
  </entry>
  <entry>
    <title>整理</title>
    <url>/2024/02/23/%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="知识的海洋无穷无尽罢"><a class="markdownIt-Anchor" href="#知识的海洋无穷无尽罢"></a> 知识的海洋无穷无尽罢!</h1>
<p>我此刻仍旧在试图让这个网页更加的好看,更加的像是我曾经的设计.</p>
<p>即使这么做确实不是很简单.</p>
<span id="more"></span>
<p><strong>有的事情说起来搞笑</strong></p>
<p>我原本想要做这个网站的时候,却没有想到上传一个Html文件,让它正常运行原来那么简单,我原本以为十分之复杂,甚至还觉得为什么微软出的东西能搞得那么复杂?!</p>
<p>哦!现在才知道,<em>一切都是那么简单,只不过是我想复杂了罢了</em>!!</p>
<p>就在谈笑间,又整出了bug…我可能是没有这种天赋来开发软件罢…</p>
<p>git是真的好用,直接回滚…很难想象没有git之前的程序员是处于怎么样的水深火热之中,某一步出错了,想找出来就很难了,而用git可以直接回滚到正常运行的版本.</p>
<p>程序员果然不能没有git!</p>
<p>-我的Bilibili<span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vNDQxMzE4NTIz" title="欢迎您！">墨泽moozy<i class="fa fa-external-link-alt"></i></span></p>
<p>-我的公众号<a href="#hellomoozy">墨泽moozy</a></p>
<p>-我的知乎<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9nYW4tZ2FuLWppbmctamluZy01MS05MA==" title="欢迎关注">干干净净我的心<i class="fa fa-external-link-alt"></i></span></p>
<p>-我的<span class="exturl" data-url="aHR0cHM6Ly9tb3plLW1heC5naXRodWIuaW8=" title="欢迎到访！">博客<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>text</tag>
      </tags>
  </entry>
  <entry>
    <title>typecho</title>
    <url>/2024/02/24/typecho/</url>
    <content><![CDATA[<p>我原本是在用着jekyll的，然后我想要想办法让我的在GitHub pages上的页面也上到我的服务器上，但是没想到服务器上安装jekyll失败了……</p>
<p>我可以继续去折腾，但是这是没有必要的……</p>
<p>是的……这是没有必要的……</p>
<span id="more"></span>
<p>我认为现在唯一必要的，就是是否有一种同步工具，可以方便地同步这两个博客上的内容。</p>
<p>如果不可行的话，那么我将会在这两个博客中的其中一个失效后使用另外一个。</p>
<p>我已经花了两天的时候攻克了在github上的博客配置，不愿意再花两天再在我的服务器上配置我的博客了。</p>
<p>typecho配置是真的很方便，再腾讯云上只需要点两下，然后复制几行命令，然后就可以直接登录进后台使用了。</p>
<p>-我的Bilibili<span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vNDQxMzE4NTIz" title="欢迎您！">墨泽moozy<i class="fa fa-external-link-alt"></i></span></p>
<p>-我的公众号<a href="#hellomoozy">墨泽moozy</a></p>
<p>-我的知乎<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9nYW4tZ2FuLWppbmctamluZy01MS05MA==" title="欢迎关注">干干净净我的心<i class="fa fa-external-link-alt"></i></span></p>
<p>-我的<a href="https://moozy.space" title="欢迎到访！">博客</a></p>
]]></content>
      <tags>
        <tag>text</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的集中遍历</title>
    <url>/2024/02/25/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉树的几种遍历"><a class="markdownIt-Anchor" href="#二叉树的几种遍历"></a> 二叉树的几种遍历</h1>
<h2 id="first"><a class="markdownIt-Anchor" href="#first"></a> FIRST</h2>
<h3 id="一些废话先写在前面"><a class="markdownIt-Anchor" href="#一些废话先写在前面"></a> 一些废话先写在前面</h3>
<p>不论是什么时候，假如你想要前进，想要进步，那就先让自己动起来，只要自己动起来了，那么很多东西都好说了。</p>
<p>很多的时候就是不想动起来，那么就今天不想动，明天不想动，后天不想动，以后也都不想动了。</p>
<p>努力的时候要想想自己是真的收获了吗，而不是只是努力了一个小时就觉得自己有收获了。</p>
<h2 id="进入正题"><a class="markdownIt-Anchor" href="#进入正题"></a> 进入正题：</h2>
<span id="more"></span>
<h4 id="什么是二叉树"><a class="markdownIt-Anchor" href="#什么是二叉树"></a> 什么是二叉树？</h4>
<p>简单的来说，那就是树的一种特型，是树中比较简单的一种，其中每个节点都有左子树和右子树（只不过有可能是空的<strong>nullptr</strong>）<br />
将示意图画出来，就像是现实中的树倒过来一样，所以叫做树，而这种树就叫做二叉树。<br />
由二叉树左右节点是否为空，是否对称等又可以引出来不同的二叉树类型，比如说完美二叉树，对称二叉树等等，但是这些二叉树只不过是在描述二叉树的样式，并不像树、二叉树的提出这么惊世骇俗，那么别出心裁。</p>
<h4 id="什么是树"><a class="markdownIt-Anchor" href="#什么是树"></a> 什么是树？</h4>
<p>树是一种形象化的说法。<br />
从根部开始，向一个方向延伸，具有多个分支结构，这样的数据就叫做树。从图像上看是如此，实际上在编程中树的构成方式有很多种，力扣中的题目大多是使用结构体，外加抽象的树类型（Treenode）的方式构成的。</p>
<blockquote>
<p>A Treenode is a data structure that represents one entry of a tree, which is composed of multiple of such nodes.<br />
The topmost node of a tree is called the “root”, and each node (with the exception of the root node) is associated with one parent node. Likewise, each node can have an arbitrary number of child nodes.</p>
</blockquote>
<h4 id="怎么求二叉树"><a class="markdownIt-Anchor" href="#怎么求二叉树"></a> 怎么求二叉树？</h4>
<p>对于一个简单的二叉树：有三种经典的遍历的方法。<br />
前序遍历：<strong>根左右</strong><br />
中序遍历：<strong>左根右</strong><br />
后序遍历：<strong>左右根</strong></p>
<p>前序遍历就是从根节点出发，先遍历到最左边的根，然后再逐一向左遍历，其中会遍历完左边的某一个节点下面的所有节点，再会去遍历这个节点的父节点的右子节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode *root, vector&lt;<span class="type">int</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="built_in">push_back</span>(root-&gt;val);<span class="comment">//将当前节点的值存到res里</span></span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;left, res);</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;right, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里以<strong>灵神</strong>的一段程序为例：</p>
<p><strong>这是一段leetcode上的代码，由灵神撰写，为了方便我直接拿来用了。</strong><br />
**这里为了方便储存数据，使用了栈，使用了递归的写法，假如下一个节点是空，那么就返回。所以我们现在模拟一下它的行动，在根节点，假如不是空节点，那么就会将当前节点的数据储存起来，也就是</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">push_back</span>(root-&gt;val)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">然后搜索左边的那一个节点，接下来，储存当前节点的数据，紧接着，又是递归到左边的节点…………  </span><br><span class="line"></span><br><span class="line">**直到左边的节点已经没有下一个数据，也就是<span class="literal">nullptr</span>的时候**，会从“下一个节点”返回到 **“最后一个有数据的节点”** ，随后，搜索“最后一个有数据的节点”的右节点……    </span><br><span class="line"></span><br><span class="line">然后就是返回到父节点，也就是上一层，再次搜索右节点，因为之前就是左节点下到了最底部，现在返回，就是搜索的从低到高的每一层节点的右节点。  </span><br><span class="line"></span><br><span class="line">这就是**前序遍历**。    </span><br><span class="line"></span><br><span class="line">那么，什么是中序遍历呢？    </span><br><span class="line"></span><br><span class="line">&gt;中序遍历：**左根右**  </span><br><span class="line"></span><br><span class="line">那么就是先递归到最左的节点，然后记录最左边的节点，然后从最左边的节点开始向上记录每一个父节点的值，然后就是父节点的右节点的值，仿照上面灵神的程序，我们可以这么写：    </span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">p</span>(root-&gt;left,ans);</span><br><span class="line">ans.<span class="built_in">push_back</span>(root);</span><br><span class="line"><span class="built_in">p</span>(root-&gt;right,ans);</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">&gt;后序遍历：**左右根**  </span><br><span class="line"></span><br><span class="line">这个也是十分简单的了，既然是左右根，那就是先是搜索到最左端节点的值，然后搜索与它同父节点的值，然后再搜索父节点的值，再以此类推。  </span><br><span class="line"></span><br><span class="line">```C++  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">p</span>(root-&gt;left,ans);</span><br><span class="line"><span class="built_in">p</span>(root-&gt;right,ans);</span><br><span class="line">ans.<span class="built_in">push_back</span>(root);</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">那么在力扣中使用的二叉树到底是什么结构呢？</span><br><span class="line">&gt;以下代码来自[leetcode](leetcode.com)  </span><br><span class="line"></span><br><span class="line">```C++ </span><br><span class="line"> <span class="comment">// Definition for a binary tree node.</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">      <span class="type">int</span> val;</span><br><span class="line">      TreeNode *left;</span><br><span class="line">      TreeNode *right;</span><br><span class="line">      <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">      <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">      <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>下面是对TreeNode结构的介绍：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;  </span><br><span class="line">      <span class="type">int</span> val;                     <span class="comment">// 节点中存储的整数值  </span></span><br><span class="line">      TreeNode *left;              <span class="comment">// 指向左子节点的指针  </span></span><br><span class="line">      TreeNode *right;             <span class="comment">// 指向右子节点的指针  </span></span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 默认构造函数，初始化节点值为0，左右子节点指针为nullptr  </span></span><br><span class="line">      <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 带一个参数的构造函数，只初始化节点值，左右子节点指针为nullptr  </span></span><br><span class="line">      <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 带三个参数的构造函数，初始化节点值以及左右子节点指针  </span></span><br><span class="line">      <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;  </span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>int val;：每个TreeNode结构体都有一个整数值val，用于存储节点的值。<br />
TreeNode *left; 和 TreeNode *right;：这两个是指针，分别指向节点的左子节点和右子节点。<br />
该结构体还提供了三个构造函数：</p>
<p>默认构造函数：这个构造函数不接受任何参数。它将val初始化为0，并将left和right指针初始化为nullptr（表示没有子节点）。</p>
<p>带一个参数的构造函数：这个构造函数接受一个整数x作为参数，将val初始化为x，并将left和right指针初始化为nullptr。</p>
<p>带三个参数的构造函数：这个构造函数接受一个整数x以及两个TreeNode指针left和right作为参数。它将val初始化为x，并将left和right指针分别初始化为传入的left和right指针。</p>
<p>这样的设计使得在创建二叉树节点时，可以根据需要选择使用哪个构造函数，从而提供更大的灵活性。</p>
<p>-我的Bilibili<span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vNDQxMzE4NTIz" title="欢迎您！">墨泽moozy<i class="fa fa-external-link-alt"></i></span></p>
<p>-我的公众号<a href="#hellomoozy">墨泽moozy</a></p>
<p>-我的知乎<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9nYW4tZ2FuLWppbmctamluZy01MS05MA==" title="欢迎关注">干干净净我的心<i class="fa fa-external-link-alt"></i></span></p>
<p>-我的<a href="https://moozy.space" title="欢迎到访！">博客</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>心态继续崩着</title>
    <url>/2024/02/27/%E5%BF%83%E6%80%81%E7%BB%A7%E7%BB%AD%E5%B4%A9%E7%9D%80/</url>
    <content><![CDATA[<h1 id="怎么说都是很难受"><a class="markdownIt-Anchor" href="#怎么说都是很难受"></a> 怎么说都是很难受</h1>
<p>看起自己的一生，总感觉自己没有什么擅长的东西。</p>
<p>假如说编程？</p>
<p>仔细看看，哪怕只是蓝桥杯这种类型的题目也就只能做个暴力。</p>
<p>说起别的，什么数学、英语、打游戏、运动，就没有一样是能比得上其他人的。</p>
<p>就没有什么能够拿得出手的玩意。</p>
<p>哪怕是那个FTF，我写的那一个程序，也没有什么人用上！即使她确实很好用了，只需要简单的点击与选择，但是……没有人用就是没有人用。</p>
<p>现如今，搭建了一个博客，wordpress、typecho、hexo、jekyll的方案我都试过了，在那么多的时间消耗之后我感觉自己什么也没有得到……</p>
<span id="more"></span>
<p>除了知道这几个玩意怎么用，知道ngnix怎么配置，知道如何编辑一些yml文件……可是说到底，这也不过只是一个博客，除了博客之外呢？我还得到了什么？而我所能学到的东西连一篇博客都凑不出来！</p>
<p>当我把手搭在我的键盘上的时候，我想写一些什么东西，但是我什么都写不出来。从我的指尖流露出来的只有这样的话语，我很痛苦得想要说一些足够让人感觉到精神振奋的玩意，比如说什么圆锥曲线大招、圆锥曲线原理、C语言精通……好！</p>
<p>看似很多东西都能说出来，但是什么都说不出来！什么都不是！</p>
<p>我什么都说不出来。</p>
<p>而再放到一个大的范围来看，哪怕是这些我觉得十分晦涩的玩意，只不过是别人的基础。这些什么二叉树的遍历，什么线段树，都不过是别人简简单单的一个课后作业，而我却需要花费几个小时去学习，才能明白这些遍历是如何运行的，这些玩意是怎么用的，但是到了最为简单的蓝桥杯上却没有办法用上这些玩意。</p>
<p>我还能干些什么呢？</p>
<p>内心还是在痛苦着。</p>
<p>不过随着我的撰写……我的内心似乎又好了一些……</p>
<p>别人终归只是简简单单的课后作业……所谓前序遍历，根左右，中序遍历，左根右，后序遍历，左右根。</p>
<p>这样的玩意我也能随口说出来，但是别人懂得用dfs来遍历么？又懂得为什么dfs是这样遍历而且能说出来解释清楚么？</p>
<p>博士……外表看起来和一个研究生，一个博士生也没有什么区别，但是一个博士，就是一个领域的最顶尖的人，不管这个领域有没有用 😂</p>
<p>那好吧……暂时平复心情，做一些有用的事情。</p>
<p>把所谓的二叉树再看看，再说说数组。</p>
<p>我不指望蓝桥杯能拿个什么奖，只要我告诉自己我做到了就好了。</p>
<p>顺便一提，我最近在看C语言二级，有点意外，里面竟然也涉及到了二叉树什么的……果然就是别人的课后作业，而我啥也不会。</p>
<p>二级比我想象中简单，后面的三道题占了60分，拿下后面的三道大题，前面的随便写写就能过。</p>
<p><strong>我不指望蓝桥杯能拿个什么奖，只要我告诉自己我做到了就好了。</strong></p>
<p><strong>相信吧。无限进步吧。</strong></p>
<p>-我的Bilibili<span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vNDQxMzE4NTIz" title="欢迎您！">墨泽moozy<i class="fa fa-external-link-alt"></i></span></p>
<p>-我的公众号<a href="#hellomoozy">墨泽moozy</a></p>
<p>-我的知乎<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9nYW4tZ2FuLWppbmctamluZy01MS05MA==" title="欢迎关注">干干净净我的心<i class="fa fa-external-link-alt"></i></span></p>
<p>-我的<a href="https://moozy.space" title="欢迎到访！">博客</a></p>
]]></content>
      <tags>
        <tag>text</tag>
        <tag>碎碎念</tag>
        <tag>someword</tag>
      </tags>
  </entry>
  <entry>
    <title>关于二叉树的层序遍历方式</title>
    <url>/2024/02/27/%E5%BF%83%E6%80%81%E5%B4%A9%E4%BA%86/</url>
    <content><![CDATA[<h1 id="心态崩了"><a class="markdownIt-Anchor" href="#心态崩了"></a> 心态崩了</h1>
<p>蓝桥杯的题好难……前面几道填空题，暴力固然可以做，可是代码量大，能保证代码写出来不出错也是很难的……而有一些题目，要进行剪枝等等操作，还有一些题目，思路都很难想……虽然看了别人的的答案之后——啊呀！不就是这么一回事么！</p>
<p>可是自己做起来就是很难搞。</p>
<p>后面的几道大题就更是很难很难了。</p>
<p>线段树、前后缀和、图论……不是我吹，吹牛可以，真写起来是一道也不会。能写个dfs就已经快到极限了，用个滚动数组、滑动窗口、二分查找优化一下就是真的极限了……</p>
<p>今年的蓝桥杯能给我来一道比较简单的动态规划，我就真的谢天谢地。</p>
<p>马上又要开学了。感觉一个寒假过去啥也没学到，啥也不是…………下个学期课还算是比较少……但是有大学物理…………先走一步看一步吧，慢慢学，慢慢努力……蓝桥杯这种玩意……今年拿不了奖还可以明年再试试，然后到大三就努力备战考研了。</p>
<h2 id="下面是代码部分"><a class="markdownIt-Anchor" href="#下面是代码部分"></a> 下面是代码部分</h2>
<h3 id="先来说说-queue"><a class="markdownIt-Anchor" href="#先来说说-queue"></a> 先来说说 queue</h3>
<p>queue和栈最大的区别是queue是先进先出的，叫做队列，栈是先进后出的，类似于一个十分窄的箱子，前面放进去的东西就只好最后才能取出来。</p>
<span id="more"></span>
<p>队列则是类似于平时的排队，先排队的人先出来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">//C++队列Queue类成员函数如下:</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">back</span>()<span class="comment">//返回最后一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">empty</span>()<span class="comment">//如果队列空则返回真</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">front</span>()<span class="comment">//返回第一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">pop</span>()<span class="comment">//删除第一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">push</span>()<span class="comment">//在末尾加入一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">size</span>()<span class="comment">//返回队列中元素的个数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>知道了queue的性质，来讲讲二叉树的层序遍历。</p>
<p><strong>所谓的层序遍历就是把二叉树的每一层的元素都遍历出来，默认是从左到右，顺序是每一层，从根节点逐层向下。</strong></p>
<p>那么输出的状态就是[[],[]]这样的，因为有的节点是有两个值的。或者不用这样只是输出排序也成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在蓝桥杯里，不像是leetcode那样一切都是封装好，只需要写一个函数即可，在蓝桥杯上，要写一个完整的函数。</span></span><br><span class="line"><span class="comment">//首先导库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//我固然知道using namespace std是一种十分不好的行为，但是在蓝桥杯里本来也用不上太多的命名，一个using就可以解决一切问题。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span> (<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//root = [3,9,20,null,null,15,7]  </span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">level</span>(TreeNode* root)&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;<span class="comment">//使用一个二维容器来储存数据。</span></span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果根节点是空的那就直接返回，下面的写法也可以实现同样的效果。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if(root ==  nullptr)</span></span><br><span class="line"><span class="comment">        return res;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    queue&lt;TreeNode*&gt; q;<span class="comment">//创建一个队列用来层序遍历</span></span><br><span class="line">    q.<span class="built_in">push</span>(root);<span class="comment">//先是将根节点入队。</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;<span class="comment">//如果当前节点不为空</span></span><br><span class="line">        <span class="type">int</span> cursize = q.<span class="built_in">size</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());<span class="comment">//往答案里添加一个容器。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;= cursize;i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();<span class="comment">//node就是当前层的最左边的节点。</span></span><br><span class="line">            q.<span class="built_in">pop</span>();<span class="comment">//删除队列中的第一个元素，注意，这个时候第一个元素已经被存到node里面了</span></span><br><span class="line">            res.<span class="built_in">back</span>().<span class="built_in">push_back</span>(node-&gt;val);<span class="comment">//向res的最后的vector存入node的值。注意这个时候node是第一个元素。然后将node所有的左右的元素也存进去。</span></span><br><span class="line">            <span class="comment">//然后继续向左右添加节点。</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) </span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);  </span><br><span class="line">    root-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>);  </span><br><span class="line">    root-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);  </span><br><span class="line">    root-&gt;right-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>);  </span><br><span class="line">    root-&gt;right-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">5</span>); </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;ans;</span><br><span class="line">    ans = <span class="built_in">level</span>(root);</span><br><span class="line">    <span class="comment">//在leetcode中此时直接return就可以结束了。</span></span><br><span class="line">    <span class="type">int</span> n = ans.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m = ans[i].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;ans[i][j];</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有几点是特别妙的"><a class="markdownIt-Anchor" href="#有几点是特别妙的"></a> 有几点是特别妙的。</h3>
<p><strong>首先就是使用队列可以减少空间开支，这样除了那些用来维护的内存、树本身的内存外只需要两层树的内存即可。</strong><br />
<strong>每一层都是root-&gt;left然后再root-&gt;right，这样本身就可以维护队列的从左到右。由于根节点只有一个，所以根节点无所谓是从左到右还是从右到左，其他的节点都是先左再右，然后再加上队列的先进先出的特点，这下子就可以实现从左到右的排列。</strong></p>
<p>说说一个朴素的做法，也就是leetcode题解中提到的那一个做法，也是类似的历遍，但是是使用哈希表，使用一个二元组记录下节点与其对应的层数，使用哈希表来储存这些数据。</p>
<p>然后输出的时候就可以使用层数作为key来输出每一层的元素了。</p>
<p>那么锯齿层序遍历是怎么搞呢？<strong>锯齿层序遍历就是每一层遍历的顺序是反过来的</strong>，这一层是从左到右，下一层就是从右到左。</p>
<p>可以在存数据进res的时候反转一下数据、或者是需要翻转的时候就把此节点的值添加到队列的尾部，同样是从左到右遍历，那么添加的时候就已经从右到左添加了。</p>
<p>-我的Bilibili<span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vNDQxMzE4NTIz" title="欢迎您！">墨泽moozy<i class="fa fa-external-link-alt"></i></span></p>
<p>-我的公众号<a href="#hellomoozy">墨泽moozy</a></p>
<p>-我的知乎<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9nYW4tZ2FuLWppbmctamluZy01MS05MA==" title="欢迎关注">干干净净我的心<i class="fa fa-external-link-alt"></i></span></p>
<p>-我的<a href="https://moozy.space" title="欢迎到访！">博客</a></p>
]]></content>
      <tags>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>碎碎念</tag>
        <tag>someword</tag>
      </tags>
  </entry>
  <entry>
    <title>一些杂项</title>
    <url>/2024/02/23/%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="first"><a class="markdownIt-Anchor" href="#first"></a> FIRST</h1>
<p>首先就是网站几乎彻底部署好了，这个方案是可行的，而且也是久经验证的。</p>
<p>在历史上，github pages也为许多的程序员提供了这样的服务，可以预见的是，在短短的几年内，github pages都不会关闭这个服务，即使Github pages 关闭了，我也依旧可以在自己的服务器上继续接力下去。</p>
<p>而且，github 被微软收购了，背靠着微软雄厚的财力，我相信github短时间内不会倒闭。</p>
<span id="more"></span>
<h1 id="secound"><a class="markdownIt-Anchor" href="#secound"></a> SECOUND</h1>
<p>github pages + vscode +markdown真的是一个非常好用的组合。</p>
<p>现在总算是可以从这些事情中解脱出来了，然后就可以用点心思去看看算法io的东西，我现在觉得这一套玩意有一点过于学术化，但是以后转码也许能用得上……此外，蓝桥杯毕竟已经交了300元的报名费。</p>
<p>不论如何，或许可以这么说，我会继续前进，继续前进，直到取得一个比较好的结果……或许可以问<strong>这一个结果</strong>是什么呢？</p>
<p>我已经有一点语无伦次了，当我思考我的未来的时候，我是迷茫的。</p>
<p>思考一下……这个时代变得太快了，一个公司，在短短的几年时间登上巅峰，又在短短的几年时间陷入低谷甚至是破产。</p>
<p>看看IBM公司，曾经的王者，现在已经默默无闻，成为了一个类似智囊团的存在，曾经的机器业务现在也所剩无几……</p>
<p>再例如NOKIA公司，现在NOKIA回归了通信的老本行，买下了AT&amp;T的贝尔实验室，但是NOKIA与贝尔实验室都没能再续辉煌。</p>
<p>关于未来的事情，又有谁能说得准？这么早就“布局未来”真的有必要？</p>
<p>你真的可以<strong>布局</strong>未来么？</p>
<h1 id="last"><a class="markdownIt-Anchor" href="#last"></a> LAST</h1>
<p>我希望公众号上可以很方便的同步markdown语法，这样可以方便我进行博客的发布……Markdown真是一个很好用的东西，在使用markdown的时候你的双手不需要离开键盘，只需要几个符号，你就可以进行大纲、加粗、斜体、标题的设置。</p>
<p>-我的Bilibili<span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vNDQxMzE4NTIz" title="欢迎您！">墨泽moozy<i class="fa fa-external-link-alt"></i></span></p>
<p>-我的公众号<a href="#hellomoozy">墨泽moozy</a></p>
<p>-我的知乎<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9nYW4tZ2FuLWppbmctamluZy01MS05MA==" title="欢迎关注">干干净净我的心<i class="fa fa-external-link-alt"></i></span></p>
<p>-我的<span class="exturl" data-url="aHR0cHM6Ly9tb3plLW1heC5naXRodWIuaW8=" title="欢迎到访！">博客<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>text</tag>
        <tag>someword</tag>
      </tags>
  </entry>
  <entry>
    <title>碎碎念</title>
    <url>/2024/02/24/%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="azure"><a class="markdownIt-Anchor" href="#azure"></a> azure</h1>
<p>今天晚上偶然看到了azure的价格计算器，在上面作为学习用途去部署静态网页竟然也是免费的！</p>
<p>这不由得令我感到欣喜若狂。</p>
<p>但是我忽然又想到，我这么费劲巴拉的到底是想要干什么呢？</p>
<span id="more"></span>
<p>本来就已经有了github pages，现在还需要这些玩意做什么？即使以后真的用上了azure的服务器，也是很久很久之后的事情了，目前来讲，或许以后考虑使用香港的服务器或者东京的服务器作为主要的动态使用的服务器来减少开支或许才是稍微有那么一点考虑价值的东西。</p>
<p>人有的时候是真的很奇妙。明明这些东西没有什么价值，但是却还是忍不住去想，假如我有这个我会怎么样，假如我实现了这个我会怎么样……亦或是，明明已经到了十分危急的关头，到了时间非常紧迫的时刻，人在那个时候却会好像突然能抓住一些空闲的时光，然后用这些空闲的时光来奢侈的干一些没什么价值的事情……</p>
<p>人是真的很神奇。</p>
<p>总而言之，确实是很感谢微软，<strong>github pages</strong> 和 <strong>azure</strong>可以免费开放有一定<strong>限制</strong>的<strong>静态网页服务</strong>，假如没有微软的付出，恐怕现在市面上的博客的数量要大大的减少了……当然，活跃的博客的占比也会大大增加……</p>
<p>免费的东西，人们得到了却总是不会珍惜。</p>
<p>这样的服务恐怕也只有国外的厂商会提供，假如国内的厂商提供了，那就一定要接入层层的审核，最终的结局就像是曾经腾讯、网易等大厂的博客一样，悄悄然地关闭。</p>
<p>在国内，如果想你要一个这样的服务，那其实也很简单，那就是进行ICP备案，可是说来简单，我的ICP备案到现在都还没有通过呢！</p>
<p>不管怎么说，到现在是时候免除这样的烦扰了，是时候去干一些有意义的事情了，把时间花在刀刃上，而不是再去折腾这个博客系统的好坏。</p>
<blockquote>
<p>人们在讨论玫瑰花的时候，不会在意她的刺是否扎手，也不会在意她的绿叶是否美丽动人。</p>
</blockquote>
<p>-我的Bilibili<span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vNDQxMzE4NTIz" title="欢迎您！">墨泽moozy<i class="fa fa-external-link-alt"></i></span></p>
<p>-我的公众号<a href="#hellomoozy">墨泽moozy</a></p>
<p>-我的知乎<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9nYW4tZ2FuLWppbmctamluZy01MS05MA==" title="欢迎关注">干干净净我的心<i class="fa fa-external-link-alt"></i></span></p>
<p>-我的<a href="https://moozy.space" title="欢迎到访！">博客</a></p>
]]></content>
      <tags>
        <tag>text</tag>
        <tag>someword</tag>
      </tags>
  </entry>
  <entry>
    <title>明日离家</title>
    <url>/2024/02/29/%E6%98%8E%E5%A4%A9%E7%A6%BB%E5%AE%B6/</url>
    <content><![CDATA[<h1 id="又到了离家的日子"><a class="markdownIt-Anchor" href="#又到了离家的日子"></a> 又到了离家的日子</h1>
<p>不知不觉已经到了29号了。ICP备案还没有通过，已经过了九天了，可能是没有通过，也可能是其他的什么原因，心累，不想再管了。</p>
<p>过不了备案就过不了备案吧，反正github.io也不需要备案。</p>
<p>不知不觉又到了离家的日子，忽然内心有一点伤悲。</p>
<p>在学校的时候想回家，在家的时候想回学校，但是到了临走的时候又会舍不得。</p>
<p>一个幸福的家庭是很有必要的，真的。家庭就是一个人的避风港，在那才能得到一点心灵的慰藉。现如今又要远离家乡，去到遥远的地方学习，进修。</p>
<p>这些东西其实都还好，其实我更加担心的一点就是……离开了家，付出了很多，但是最终却没有什么收获。我最担心的就是这个。</p>
<p>怎么说呢……等到我毕业的时候，我两手空空，抱着一份简历不知道能投到什么公司的hr手里，在那个时候才是真正的痛苦。</p>
<p>为了这一切舍弃了那么多，最终你又得到了什么？我最怕的就是我什么都没有得到。</p>
<h1 id="我心安处是吾乡"><a class="markdownIt-Anchor" href="#我心安处是吾乡"></a> 我心安处是吾乡</h1>
<p>苏轼曾经说过一句话，叫做<em>我心安处是吾乡</em>。</p>
<p><em><strong>我十分的认同。</strong></em></p>
<p>当我远离我的家乡的时候，我所能依靠的就只有内心的安定了。有一句话叫做<strong>随遇而安</strong>，随遇而安是很重要的品质，*只有你的内心安定下来了，你才能把你自己的内心安定下来。*这一句话听起来像是一句废话，但是其实是指不同层面的内心安定。</p>
<p>一个人在外，奔波，安定是很少有的。</p>
<p>内心总是会有慌张与急促。</p>
<p>也就正如我所说，*只有你的内心安定下来了，你才能把你自己的内心安定下来。*一个是安定的内心，一个是内心的安定。</p>
<p>总而言之呢……我又到了新的一个学期，看课表和上一个学期也差不多，少了一些课，也多了一些课，但是总体来看，每一周的排课量是有所减少的。</p>
<h1 id="说些奋斗的话"><a class="markdownIt-Anchor" href="#说些奋斗的话"></a> 说些奋斗的话</h1>
<h2 id="现实中的作为"><a class="markdownIt-Anchor" href="#现实中的作为"></a> 现实中的作为</h2>
<p>当你在高中的时候，你会总是感觉大学的生活十分美好，每天早上八点才要上课，每天即使有晚修也下得很早，这样的日子，你的内心有什么不满足的？</p>
<p>但是这个就是事实，是真的不满足。</p>
<p>当你可以每天早上八点再上课的时候，你就会想要九点再上课，如果可以不上课，你会更加想要永远不上课。</p>
<p>给了自己借口去放松，那么就会一直放松下去了。</p>
<p>这一点，哪怕是什么清华北大的人也没有办法免俗。</p>
<p><strong>当然了，任何一个学校都会有坚持下去不懈奋斗的人</strong>这样的人是有勇气，有毅力，更有前途的。我也希望他们可以坚持下去，因为不论什么事情，都是坚持最难，抛去酷刑不谈，平淡、坚持，才是最会让人崩溃的。</p>
<p>哪怕是酷刑，也不是一下子就招的，要么是心理压力，要么是真的上了酷刑，总归是要有一个坚持的过程。</p>
<p>正如士兵突击中所说：<strong>光荣在于平淡，艰巨在于漫长</strong>。</p>
<p>在我高三的时候，我也把这一句话当作我的座右铭，当然，我到了最后的关头，最后的那几个星期实在是坚持不下去了，作业还是做，题还是刷，但是没有那种充沛的热情去做事，失去了激情，就好像是草原上的五班一样，还是照样站岗，还是照样巡逻，但是已经和没来到五班之前的样子不一样了。</p>
<p><em><strong>不一样太多了。</strong></em></p>
<p>那么这一个新的学期，就还是做新的模样，在家里面补充好了能量，到了新的学期就努力拼搏。</p>
<h2 id="网上的人总是说奋斗无用"><a class="markdownIt-Anchor" href="#网上的人总是说奋斗无用"></a> 网上的人总是说奋斗无用</h2>
<p>到底有没有用呢？我也不知道。可是我现在除了奋斗还有什么路子？难道我现在去工厂打工，难道我现在抛弃学业会是更好的行为？<strong>恐怕我不能苟同</strong>。不论如何，在现在，还能有一些机会来提高自己的实力，那就先提高自己的实力。当你连蓝桥杯都不敢说能秒杀的时候，你又有什么信心说可以去通过大厂的面试？</p>
<p>哪怕人们都说：<strong>码农根本用不上那些东西</strong>，<em>那也是先进了大厂才会有这样的觉悟</em>，你连别人的门槛都过不去，<em><strong>你管别人门槛后是比门槛高还是比门槛低</strong></em>？</p>
<h2 id="低调做人高调做事"><a class="markdownIt-Anchor" href="#低调做人高调做事"></a> 低调做人，高调做事</h2>
<p>我听过说这样一句话：<em>低调做人，高调做事</em>。仔细想想，大体上是对的。低调做人可以不给自己带来敌人，高调做事往往更加容易成功。<strong>（高调做事，让别人高看你一眼，让别人对你更加地尊重，你所有用的条件就会更加有用。）</strong></p>
<p>就先这样吧。</p>
<p>再等一会，让命运的齿轮再转一会。</p>
<p>-我的Bilibili<span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vNDQxMzE4NTIz" title="欢迎您！">墨泽moozy<i class="fa fa-external-link-alt"></i></span></p>
<p>-我的公众号<a href="#hellomoozy">墨泽moozy</a></p>
<p>-我的知乎<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9nYW4tZ2FuLWppbmctamluZy01MS05MA==" title="欢迎关注">干干净净我的心<i class="fa fa-external-link-alt"></i></span></p>
<p>-我的<a href="https://moozy.space" title="欢迎到访！">博客</a></p>
]]></content>
      <tags>
        <tag>text</tag>
        <tag>someword</tag>
      </tags>
  </entry>
  <entry>
    <title>睡前的话</title>
    <url>/2024/02/29/%E7%9D%A1%E5%89%8D%E7%9A%84%E8%AF%9D/</url>
    <content><![CDATA[<p>昨天刚想说ICP备案要备个半天，没想到昨天刚把博客写完半个小时ICP备案通过的通知就下来了。</p>
<p>虽然通过了，但是还没有向腾讯云同步，所以通过了也暂时没有办法通过域名访问我的网站，等到今天应该就可以实现了。</p>
<p>然后现在是在等公安的备案。</p>
<p>这个应该很简单，毕竟我这个网站啥也没有，没有评论，没有通知，没有注册。</p>
<p>有的只是我一个人的狂欢。</p>
<p>-我的Bilibili<span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vNDQxMzE4NTIz" title="欢迎您！">墨泽moozy<i class="fa fa-external-link-alt"></i></span></p>
<p>-我的公众号<a href="#hellomoozy">墨泽moozy</a></p>
<p>-我的知乎<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9nYW4tZ2FuLWppbmctamluZy01MS05MA==" title="欢迎关注">干干净净我的心<i class="fa fa-external-link-alt"></i></span></p>
<p>-我的<a href="https://moozy.space" title="欢迎到访！">博客</a></p>
]]></content>
      <tags>
        <tag>someword</tag>
      </tags>
  </entry>
  <entry>
    <title>节约空间地求余</title>
    <url>/2024/03/07/%E8%8A%82%E7%BA%A6%E7%A9%BA%E9%97%B4%E5%9C%B0%E6%B1%82%E4%BD%99/</url>
    <content><![CDATA[<p>这个是leetcode的2575题。<br />
对于这一道题，固然可以这样来处理cnt的数据：</p>
<pre class="highlight"><code class="C++">cnt = cnt *= <span class="number">10</span> + num;
</code></pre>
<p>但是这么写却又隐患——那就是当遇到特别大，接近long long 的极限的长度的数字的时候，就没有办法再*=10了。</p>
<p>这个文章将给你介绍如何节约空间。</p>
<pre class="highlight"><code class="C++"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;
<span class="keyword">public</span>:
    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">divisibilityArray</span><span class="params">(string word, <span class="type">int</span> m)</span> </span>&#123;
        <span class="type">int</span> n = word.<span class="built_in">size</span>();
        vector&lt;<span class="type">int</span>&gt;ans;
        <span class="type">long</span> <span class="type">long</span>  cnt = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">auto</span> q:word)&#123;
            <span class="keyword">auto</span> num = q -<span class="string">&#x27;0&#x27;</span>;
            cnt = (cnt * <span class="number">10</span> + num) % m;
            <span class="keyword">if</span>(cnt % m == <span class="number">0</span>)&#123;
                ans.<span class="built_in">emplace</span>(ans.<span class="built_in">end</span>(),<span class="number">1</span>);
            &#125;
            <span class="keyword">else</span>&#123;
                ans.<span class="built_in">emplace</span>(ans.<span class="built_in">end</span>(),<span class="number">0</span>);
            &#125;
        &#125;
        <span class="keyword">return</span> ans;
        
    &#125;
&#125;;
</code></pre>
<p>在运算的途中就将数据给处理了，那么每一次运算的结果都会明显减少，至少不需要再记录那个非常大的数字了。</p>
<p>假如需要更大的数字，那么可以使用数组来处理。</p>
<p>但是在这个时候是用不上的。</p>
<p>为什么可以在计算过程中求余呢？</p>
<p><strong>可以将求余数分为两个部分，一个是可以被求余的，还有一部分是多出来的。假如是可以被求余的数，那么多出来的就是0；在这个基础上，每一次求余都会将前面可以求余的部分余去，那么两个数字相加的和求余的时候也是同样的，两个数字的可以求余的部分被余去，然后剩下余数。</strong></p>
<p>由此，通过在计算过程中求余，就可以显著减少空间占用。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>到达上海</title>
    <url>/2024/03/03/%E5%88%B0%E8%BE%BE%E4%B8%8A%E6%B5%B7/</url>
    <content><![CDATA[<p>为了减少obs资源开支，可以前往我的公众号访问。</p>
<p>不是可怜这一点obs资源，而是本来就没人看，全浪费给爬虫了。</p>
<p>假如有人看我是不在意这一点消耗的。</p>
<p><img src="https://moozy.space/picture/%E4%B8%8A%E6%B5%B7%E6%9C%BA%E5%9C%BA%E5%80%99%E6%9C%BA%E5%AE%A4.jpg" alt="候机楼" /></p>
<p>-我的Bilibili<span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vNDQxMzE4NTIz" title="欢迎您！">墨泽moozy<i class="fa fa-external-link-alt"></i></span></p>
<p>-我的公众号<a href="#hellomoozy">墨泽moozy</a></p>
<p>-我的知乎<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9nYW4tZ2FuLWppbmctamluZy01MS05MA==" title="欢迎关注">干干净净我的心<i class="fa fa-external-link-alt"></i></span></p>
<p>-我的<a href="https://moozy.space" title="欢迎到访！">博客</a></p>
]]></content>
      <tags>
        <tag>someword</tag>
      </tags>
  </entry>
  <entry>
    <title>learn_numpy</title>
    <url>/2024/03/06/learn-numpy/</url>
    <content><![CDATA[<h1 id="这是一篇关于numpy库的博客"><a class="markdownIt-Anchor" href="#这是一篇关于numpy库的博客"></a> 这是一篇关于numpy库的博客</h1>
<h2 id="忽然记起自己还有一场数学建模的任务"><a class="markdownIt-Anchor" href="#忽然记起自己还有一场数学建模的任务"></a> 忽然记起自己还有一场数学建模的任务</h2>
<p>感觉单单是什么蓝桥杯、电设赛云者已经很让人疲惫了，不过数学建模是一种很重要的技能。</p>
<p>这个博客不可能一次性更新完，会慢慢更新。</p>
<p>在这个博客中，我会介绍我关于numpy的学习经验。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>还在美化</title>
    <url>/2024/03/13/%E8%BF%98%E5%9C%A8%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<h1 id="还是在美化的道路上越走越远了"><a class="markdownIt-Anchor" href="#还是在美化的道路上越走越远了"></a> 还是在美化的道路上越走越远了</h1>
<p>这个周想要修复博客的sitemap功能，还想要修复博客的搜索功能。</p>
<p>这两点都还算是比较好处理，虽然也费了点时间，也掉了点头发，但是其实是非常简单的，因为有直接可用的库，几行代码就可以完事了。</p>
<p>我所遇到的问题主要是npm下载的时候没有下载到hexo的文件夹中，而是下载到了根目录下，我今天忽然想起来这件事，查询可知，确实是需要下载到hexo的根目录中的。</p>
<p><strong>当我修复了这一错误的时候，他们终于开始正确地工作了。</strong><br />
<em>下面，我还要再解决http跳转https的任务</em></p>
<p>同时还想要实现这样的功能：<em><strong>给博客新建一个wiki页，然后实现在wiki页中发布专属于wiki的内容，就像是next的示例博客中那样。</strong></em></p>
<p>但是让人沮丧的是，我没有在next的示例博客中找到我想要的介绍，似乎直接略过了这一部分。</p>
<p>而http跳转的ngnix代码也无法正常工作。</p>
]]></content>
      <tags>
        <tag>服务器</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>a week</title>
    <url>/2024/03/09/a-week/</url>
    <content><![CDATA[<h1 id="first"><a class="markdownIt-Anchor" href="#first"></a> first</h1>
<p>这周还挺无聊的。做了一些工作，但是做得不多。</p>
<p>仔细想想，这是一件挺让人沮丧的事情：这个星期做得不多，按照的是学校的进度来走，在学校的进度之外我就基本没有自己的突出的地方了。</p>
<p>当然，可以这么说：我从很早开始就每天都背单词，这个星期也没有例外，背了几百个单词，又复习了几百个单词，可惜的是，即使背了也不代表四级的题就会写了，也不代表英语的水平就上去了，更不代表今天背了明天就不会忘。</p>
<!-- more --->
<p>除此之外，这周做了些无聊的幻想。具体来说，我查找了如何写一个数学论文，还略微看了几眼letax（希望没有拼错）的语法，当然，最后我觉得typst才是用起来最方便的。随后我又在想如何使用typst来替代markdown来写博客。</p>
<p>于是霎时之间，我又感觉到自己的时间被极大的浪费了。</p>
<p>***其实可不就是这么一回事：本来就有的东西，非得整个高大上的替代品，为了自己用不上的功能而付费。***当然，这里的付费指的是付出时间与精力，假如真的要花钱，那么我是不会去参加的，作为一个大学生，时间可能有一些富余，但是钱是真的没有什么富余。</p>
<p>昨天晚上跑了三公里。三公里固然算不上什么，但是跑三公里真的可以给你带来<strong>快乐与舒心</strong>。即使跑完了大腿疼，乏力，但是不可否认的是在跑步的过程中是快乐的，我上个学期也经常承受这样的快乐，但是当时的心理还没有此时那么的开朗，所以当时也就无法体会现如今的快乐。<br></p>
<p>所有的一切，使用英文来写都是最好的。例如说markdown这个词汇，假如说我的输入法没有把这个词收录进去，我在输入这个词的时候，要么就切换成英文，要么就顶着那一堆的拼音强行输入。再例如<code>&lt;br&gt;</code>、<code>``</code>，只有在英语模式下才可以流畅地输入，在中文模式下输入就会十分繁琐。</p>
<p>假如你不使用<code>&lt;br&gt;</code>，那么你就只能在句子的后面打两个空格。</p>
<p>但是假如我忽略了两个空格，我也没有办法看出来我到底打没打空格。</p>
<p>中文编程固然不好，但是在某些方面也是有其好处的。说到底，这一切都是外国人主导，就像是铁路仿照马车痕一样，已经没有办法更改了。</p>
<table>
<thead>
<tr>
<th>h</th>
<th>e</th>
<th>l</th>
<th>l</th>
<th>o</th>
<th>!</th>
</tr>
</thead>
</table>
<br>
要说起来，现在markdown的玩意我都可以玩得很溜了，然后说回专业的使用markdown生成图表云者，我没有使用场景，也就懒得去学。   
<p>假如真的有用上的时候，那我为什么不用python画图，然后直接把图片嵌进来呢？</p>
<p>亦或者，为什么不用typst呢？</p>
<p>本来很多东西就没有必要all in one ，各取所取，各有所长才是最好的。</p>
]]></content>
      <categories>
        <category>周记</category>
      </categories>
      <tags>
        <tag>text</tag>
        <tag>someword</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是markdown？</title>
    <url>/2024/03/16/what_is_md/</url>
    <content><![CDATA[<h1 id="什么是markdown"><a class="markdownIt-Anchor" href="#什么是markdown"></a> 什么是markdown？</h1>
<p>markdown是一种轻量级的标记语言。</p>
<p><em><strong>markdown不是一种编程语言</strong></em>，不像C++、C那样可以编写什么程序，如果要一定要将markdown与编程语言扯上关系的话，<strong>markdown更像是python一类的脚本语言</strong>。</p>
<p>markdown通过一些简单的标记，实现标题段、加粗、斜体、下划线、表格、代码块等功能，使用一些加强插件可以实现输入数学符号、生成图表等高级用法。</p>
<!--more--->
<p>markdown本身并不可直接被转换，也就是说，当你打开.md文件或者.markdown文件的时候，你可以看见的就只是那一堆带有<code>#</code>、<code>*</code>等符号的文本，就像是一个txt文件一样。那么你把markdown文件拖进浏览器中又会怎么样呢？</p>
<p>很遗憾，假如说你的浏览器没有装上指定的插件的话，依旧只会显示同样的内容：<em><strong>一堆带有<code>#</code>、<code>*</code>等符号的文本，就像是一个txt文件一样</strong></em>，那么我们为什么要使用markdown呢？</p>
<h1 id="那么我们为什么要使用markdown呢"><a class="markdownIt-Anchor" href="#那么我们为什么要使用markdown呢"></a> 那么我们为什么要使用markdown呢？</h1>
<p>答案是没有必要，但是在前端工作的时候，markdown是一种很方便地东西。</p>
<ul>
<li>此时，大多数的样式，比如说标题，加粗等效果，页面的背景，字体的大小等等属性都已经被确定好了；</li>
<li>此时你所需要做的就是输入文字，生成文件；</li>
<li>那么这个时候使用word太笨重，而且不一定适用，并且会遇到各种兼容性问题，</li>
<li>使用txt又没有格式，压根就没法用上前端所设计好的元素。<br />
于是此时，markdown就可以大展身手。</li>
</ul>
<p>除非遇上了网页前端不支持你所使用的图表、数学语法而你又恰好使用这些标准之外的东西，否则，你的markdown文件可以完美地按照程序员所设计的样式转换成html文件。</p>
<p>这也是为什么个人博客、github的readme文件都使用markdown的原因了。</p>
<p>我们是否一定要使用markdown，**甚至为了markdown抛弃word、txt或者别的什么文本格式呢？**我的答案是：<br />
<em><strong>这是完全没有必要的</strong></em>；</p>
<h1 id="什么时候使用markdown"><a class="markdownIt-Anchor" href="#什么时候使用markdown"></a> 什么时候使用markdown？</h1>
<p>markdown最好的战场就是我所说的情况，只需要专注于内容，而不需要在意格式的情况。</p>
<p><em>这种特定的情况并不是什么时候都可以遇到，我们只需要在遇到这样的需求的时候优先考虑到markdown格式是否可以给我们带来收益即可。</em></p>
<blockquote>
<p>而且不得不说的一点是：markdown文件在编写的时候可以完全不用鼠标，你可以一直写到尾，全程只需要注视着屏幕，双手连续打字即可。</p>
</blockquote>
<p>假如你有这样的专注工作的需求，markdown是一种十分完美的选择。</p>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>wiki</tag>
      </tags>
  </entry>
  <entry>
    <title>第二周不妨写点东西</title>
    <url>/2024/03/16/%E7%AC%AC%E4%BA%8C%E5%91%A8%E4%B8%8D%E5%A6%A8%E5%86%99%E7%82%B9%E4%B8%9C%E8%A5%BF/</url>
    <content><![CDATA[<h1 id="first"><a class="markdownIt-Anchor" href="#first"></a> FIRST</h1>
<p>这一周我把hexo重新部署到我的本地。</p>
<p>然后通过git的方法链接我的服务器与github pages。</p>
<p>所以，现在看起来，一切都十分完美。我可以随时断网写作，不用担心数据没有保存，也不用担心没有网络的情况。</p>
<p>其实都只不过是一些十分简单的工作，但是却花费了我不少的时间，**对此我确实应当作出反思。**一个人的时间是很宝贵的，是最为珍贵的一种不可再生资源。浪费时间无疑是谋财害命，同时这样的日子，比如说最开始我使用jekyll来制作github pages 网页的时候，更是花费了我很多的时间，那个时候甚至我在废寝忘食地工作着。</p>
<p><strong>那个时候我对于这方面的知识一窍不通</strong>，但是我对<em>其感兴趣</em>，于是我很快就入门了。</p>
<p>我深刻认识到，什么叫做<strong>兴趣才是最好的老师</strong>。只要你对一件事感兴趣，那么你就会充满动力地坚持下去。</p>
<blockquote>
<p><em><strong>当然了，保重身体也是很重要的。</strong></em></p>
</blockquote>
<h1 id="second"><a class="markdownIt-Anchor" href="#second"></a> SECOND</h1>
<p>这周我所做依旧不多，但是我对此做了一些反思。</p>
<p>我认为一个人不应该有太大的压力，假如一个人是快活的快乐的，那么他自然而然会极具有创造力。</p>
<p>我总是给自己很大的压力，我认为这就叫做精神内耗。我总是处于一种精神内耗而且焦虑的过程中，那么原本简单的东西对于我来讲也会变得困难，原本困难的东西对于我那我更是不会想要去参与。</p>
<p>于是我决心改变这样的情况，放下焦虑，（而不是放弃努力），看向眼前，该玩的时候玩玩，该学的时候学，不去担心考试，不去担心未来，坚持做好每一秒的事情。</p>
<h1 id="third"><a class="markdownIt-Anchor" href="#third"></a> THIRD</h1>
<ul>
<li>计算机二级不是什么难事。</li>
<li>英语四级难度只是比高考略高，我连高考都不怕，难道我还会惧怕这个英语四级？</li>
<li>这个学期有一些比赛，但是有学长一起参赛，我并不是主力，等到下一个学期，我就已经有了足够的实力去带队，这一切都不是问题</li>
<li>这个学期有模电这样很难的课，但是我难别人也难，我比别人更花时间去研究，不说超越别人，至少考试对于我来讲，那将是不难的</li>
</ul>
<p>我打算接下来的时间继续写文章，继续研究算法，继续研究stm32，继续学数学，学英语。</p>
<p>然后一步一步走，不走太快，不背离自己的初衷。</p>
<p><strong>我认为这样就已经足够了。</strong></p>
]]></content>
      <categories>
        <category>周记</category>
      </categories>
      <tags>
        <tag>text</tag>
        <tag>someword</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2024/03/17/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表"></a> <strong>哈希表</strong></h1>
<p>有的时候，我们需要记录下我们所做的事情，在初学阶段，我们可以使用数组或者容器来进行记录，但是当数据量十分巨大的时候，那么使用哈希表来进行数据的记录会十分方便而且快捷，并且不用担心出现爆栈之类的问题。</p>
<p>在C++中的哈希表实现有三个函数：<code>map</code>,<code>multimap</code>,<code>unordered_map</code>，前面两个函数的实现是利用了红黑树，<code>unordered map</code>的实现是使用了哈希结构直接做映射。</p>
<p>在实际使用中大多数是使用<code>unordered_map</code>，因为使用<code>unordered_map</code>进行查找、删改的效率是最高的。<br />
前面两个函数由于通过在内部实现红黑树的方法来实现哈希表，所以内存占用大，但是在处理一些具有顺序的表的时候更加快速。</p>
<p><code>unordered_map</code>的使用示例：<code>unordered_map&lt;string,int&gt;mp;</code>//表示键值对由string 映射到 int.<br />
<code>unordered_map</code>函数中常用的成员方法：</p>
<p><code>at(key)</code>返回容器中储存的键key对应的值，如果key不存在，则会抛出<code>out_of_range</code>异常、<code>find(key)</code>查找以key为键的键值对，如果找到，那么就返回一个指向这个键值对的正向迭代器，反之则返回指向容器中最后一个键值对之后的位置的迭代器（<code>end()） 、count(key)</code>在容器中查找以key作为键的键值对的个数、<br />
<code>emplace()</code> 在容器中添加新键值对，效率比<code>insert()</code>高、</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt;map;</span><br><span class="line">map[<span class="string">&quot;hello&quot;</span>] = <span class="number">1</span>;</span><br><span class="line">map.<span class="built_in">emplace</span>(<span class="string">&quot;number&quot;</span>, <span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;map[hello] = &quot;</span> &lt;&lt; map[<span class="string">&quot;hello&quot;</span>] &lt;&lt; <span class="string">&quot;map[\&quot;number\&quot;] = &quot;</span> &lt;&lt; map[<span class="string">&quot;number&quot;</span>] &lt;&lt; endl;</span><br><span class="line">out：</span><br><span class="line">map[hello] = <span class="number">1</span>map[<span class="string">&quot;number&quot;</span>] = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>insert()</code> 向容器中添加键值对、</li>
<li><code>erase()</code>删除指定键值对、</li>
<li><code>erase(pos,n)</code>; 删除从pos开始的n个字符，比如erase(0,1)就是删除第一个字符</li>
<li><code>erase(position)</code>;删除position处的一个字符(position是个string类型的迭代器)</li>
<li><code>erase(first,last)</code>;删除从first到last之间的字符（first和last都是迭代器）</li>
<li><code>clear()</code>清空容器、</li>
<li><code>swap()</code>交换两个unordered_map容器储存的键值对，前提是必须保证这两个容器的类型完全相同。<br />
记录某一个元素出现的次数：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;cnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    cnt[q]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> q : cnt) &#123;</span><br><span class="line">    cout &lt;&lt; q.first&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;q.second&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//q.first就是键,q.second就是值。</span></span><br></pre></td></tr></table></figure>
<p>以下为文心一言的回答：<br />
/**************************************************************************<br />
当然！以下是几个C++中使用哈希表的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例子1：使用unordered_map实现哈希表</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">()</span></span>&#123;      </span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">int</span>&gt; hashTable;  <span class="comment">// 添加键值对      </span></span><br><span class="line">    hashTable[<span class="string">&quot;apple&quot;</span>] = <span class="number">5</span>;      </span><br><span class="line">    hashTable[<span class="string">&quot;banana&quot;</span>] = <span class="number">7</span>;      </span><br><span class="line">    hashTable[<span class="string">&quot;orange&quot;</span>] = <span class="number">3</span>;  <span class="comment">// 查找键值对      </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;apple: &quot;</span> &lt;&lt; hashTable[<span class="string">&quot;apple&quot;</span>] &lt;&lt; std::endl;  <span class="comment">// 遍历哈希表  </span></span><br><span class="line">    <span class="keyword">for</span> (constauto&amp; entry : hashTable) &#123;          </span><br><span class="line">        std::cout &lt;&lt; entry.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; entry.second &lt;&lt; std::endl;      </span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例子2：自定义哈希函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span><span class="comment">// 自定义哈希函数  </span></span></span><br><span class="line">structHashFunction &#123;  </span><br><span class="line">std::<span class="built_in">size_toperator</span>()(<span class="type">const</span> std::pair&lt;std::string, <span class="type">int</span>&gt;&amp; key)<span class="type">const</span>&#123;          </span><br><span class="line">std::<span class="type">size_t</span> hash = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">for</span> (constauto&amp; c : key.first) &#123;              </span><br><span class="line">hash += std::<span class="built_in">hash</span>&lt;<span class="type">char</span>&gt;()(c);          </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> hash ^ (key.second &lt;&lt; <span class="number">1</span>); <span class="comment">// 或使用boost::hash_combine (需要包含boost/functional/hash.hpp)      </span></span><br><span class="line">&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">()</span></span>&#123;      </span><br><span class="line">std::unordered_map&lt;std::pair&lt;std::string, <span class="type">int</span>&gt;, std::string, HashFunction&gt; hashTable;  </span><br><span class="line"><span class="comment">// 添加键值对      </span></span><br><span class="line">hashTable[&#123;&#123;<span class="string">&quot;apple&quot;</span>, <span class="number">5</span>&#125;&#125;] = <span class="string">&quot;red&quot;</span>;      </span><br><span class="line">hashTable[&#123;&#123;<span class="string">&quot;banana&quot;</span>, <span class="number">7</span>&#125;&#125;] = <span class="string">&quot;yellow&quot;</span>;      </span><br><span class="line">hashTable[&#123;&#123;<span class="string">&quot;orange&quot;</span>, <span class="number">3</span>&#125;&#125;] = <span class="string">&quot;orange&quot;</span>;  </span><br><span class="line"><span class="comment">// 查找键值对      </span></span><br><span class="line">std::cout &lt;&lt; hashTable[&#123;&#123;<span class="string">&quot;apple&quot;</span>, <span class="number">5</span>&#125;&#125;] &lt;&lt; std::endl;  </span><br><span class="line"><span class="comment">// 遍历哈希表  </span></span><br><span class="line"><span class="keyword">for</span> (constauto&amp; entry : hashTable) &#123;          </span><br><span class="line">std::cout &lt;&lt; entry.first.first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; entry.first.second &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; entry.second &lt;&lt; std::endl;      </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这些例子演示了如何使用unordered_map容器来实现哈希表，并在其中存储和访问键值对。第一个例子使用了默认的哈希函数，而第二个例子自定义了哈希函数。这只是C<ins>中实现哈希表的简单示例，实际上还有更多的用法和扩展可以探索。请注意，为了运行这些示例，您需要编译器支持C</ins>11或更高版本。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>PCB</title>
    <url>/2024/03/17/PCB/</url>
    <content><![CDATA[<h1 id="为什么学pcb板子"><a class="markdownIt-Anchor" href="#为什么学pcb板子"></a> 为什么学PCB板子？</h1>
<h2 id="洞洞板的方式十分不方便"><a class="markdownIt-Anchor" href="#洞洞板的方式十分不方便"></a> 洞洞板的方式十分不方便</h2>
<p>洞洞板最首先是所有的线都在背面裸露出来，必然要受到腐蚀与磨损，随着时间的流逝，与PCB板子相比，<strong>“短时间”内必然会降低性能甚至损毁。</strong></p>
<p>其次，洞洞板的形式会让电路巨大，不利于使用与携带。</p>
<h2 id="pcb板是整个电路的载体"><a class="markdownIt-Anchor" href="#pcb板是整个电路的载体"></a> PCB板是整个电路的载体</h2>
<p>PCB板上有各个元件的连线，连接起不同的组件。</p>
<p>我们一般设计好PCB板之后，发给淘宝店家让其打板，一周左右能到。</p>
<p><strong>PCB是整个电路的载体</strong>，我们在PCB板上进行焊接，得到以PCB板为载体的电路。</p>
<h2 id="实践极其重要"><a class="markdownIt-Anchor" href="#实践极其重要"></a> 实践极其重要</h2>
<p><em><strong>不论怎么说，PCB板可以在网上找例子，但是想要真正学会，那你必须要自己画，自己设计出来板子，然后自己找人生产，然后自己测试板子。</strong></em></p>
<p>理论上的功夫很简单，但是想要真正学会，那么就一定要勤画板子。</p>
<p>我的老师说，你自己的板子就会像是一个艺术品一样。</p>
<h1 id="如何开始"><a class="markdownIt-Anchor" href="#如何开始"></a> 如何开始？</h1>
<h2 id="首先要下载软件"><a class="markdownIt-Anchor" href="#首先要下载软件"></a> 首先要下载软件</h2>
<p><em><strong>altium Designer</strong></em></p>
<h3 id="软件管家"><a class="markdownIt-Anchor" href="#软件管家"></a> 软件管家</h3>
<p>你可以去关注一个叫做软件管家的公众号</p>
<p>上面会给你下载软件的链接。</p>
<p>软件名字叫做altium Designer。</p>
<h3 id="为什么不用proteus"><a class="markdownIt-Anchor" href="#为什么不用proteus"></a> 为什么不用proteus?</h3>
<p>proteus也能画，但是与淘宝上的PCB厂不好对接，也就说你使用proteus也可以做，但是不好进行实现，顶多使用Proteus仿真。</p>
<p>因此使用altium Designer是最好的。</p>
<h1 id="要学会自己画封装"><a class="markdownIt-Anchor" href="#要学会自己画封装"></a> 要学会自己画封装</h1>
<p><em>库用的时候才会觉得少</em></p>
<ul>
<li>
<p>建立工程文件夹<br />
所有的东西都是在工程文件夹里面找。<br />
然后给其保存</p>
</li>
<li>
<p>建立资源文件夹<br />
doc<br />
pcb<br />
……</p>
</li>
<li>
<p>建立符号库</p>
</li>
<li>
<p>建立封装库</p>
</li>
</ul>
<p><strong>原理图是功能设计，pcb图是加工设计，封装是原理图符号所对应的元件的外形尺寸与引脚信息，PCB板是电路的载体</strong></p>
<h3 id="原理图"><a class="markdownIt-Anchor" href="#原理图"></a> 原理图</h3>
<p>只要信息对就行，谁说符号就是那个符号？<em><strong>只要上面标注的信息对即可</strong></em>。</p>
<p>所以在原理图上可以看见很多各种各样的块。</p>
<p>只要一个方框，然后上面画上四根线，那就是USB口不行么？只要上面的引脚信息、大小信息与实际上的USB口一样不就可以了？</p>
<p>所以很多的东西并没有对应的符号，只需要一个黄色块即可。</p>
<h3 id="封装"><a class="markdownIt-Anchor" href="#封装"></a> 封装</h3>
<p>没有绝对完美的封装库</p>
<p>要学会自己按照原理图设计封装。</p>
<p>那么到最后你就真正自己学会了PCB。</p>
<h1 id="pcb板的制作"><a class="markdownIt-Anchor" href="#pcb板的制作"></a> PCB板的制作</h1>
<blockquote>
<p>首先需要覆铜板</p>
</blockquote>
<p>中间是玻璃纤维，外面覆盖铜箔</p>
<p>在上面钻出来孔。PCB板上面的孔就是这么来的。</p>
<p>电镀在孔中上铜。</p>
<p>在上下贴蓝膜，再贴黑膜，只有在需要导线的地方露出来，其余部分不透光，用紫外线进行照射，于是需要导线的地方变紫了。</p>
<p>在用显影液将蓝膜上的蓝色洗掉。</p>
<p>然后使用三氯化铁进行置换反应，将紫色的地方保留下来，上面的铜就形成了导线。</p>
]]></content>
      <categories>
        <category>电路</category>
        <category>硬件</category>
      </categories>
  </entry>
  <entry>
    <title>静态工作点</title>
    <url>/2024/03/17/%E9%9D%99%E6%80%81%E5%B7%A5%E4%BD%9C%E7%82%B9/</url>
    <content><![CDATA[<h1 id="什么是静态工作点"><a class="markdownIt-Anchor" href="#什么是静态工作点"></a> 什么是静态工作点？</h1>
<p>三极管有静态工作与动态工作两种状态。</p>
<p>静态工作点就是将交流电源输出信号为零的时候放大电路的工作状态，比如IB的大小此时就是IBQ。</p>
<p>所以在求静态工作点的时候要先把交流电路变成直流电路。</p>
<h2 id="未完待续"><a class="markdownIt-Anchor" href="#未完待续"></a> 未完待续</h2>
]]></content>
      <categories>
        <category>电路</category>
        <category>模电</category>
      </categories>
  </entry>
  <entry>
    <title>SVM向量机初入门</title>
    <url>/2024/03/15/SVM%E5%90%91%E9%87%8F%E6%9C%BA%E5%88%9D%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="svm向量机"><a class="markdownIt-Anchor" href="#svm向量机"></a> SVM向量机</h1>
<p>使用SVM向量机将数据进行区分。</p>
<p>由于markdown中不方便插入图片，所以就略去不谈，示意的图片可以在网上找到很多。</p>
<p>总的来讲，通过SVM向量机对数据进行处理，训练模型，然后通过模型去推测更多的数据。</p>
<blockquote>
<p>也就是我下面所说的那个<em>分类与预测</em>；</p>
</blockquote>
<p>最直接的做法就是：<strong>最接近的两个元素之间的距离，不同的两个元素之中会有不同的距离，找出最大的那一个距离，使得你的区分线鲁棒性最强。</strong></p>
<p>由于我们整个SVM向量机都是一个预测的使用目的，你的区分模型鲁棒性越强，那么后续的预测就会更加准确。</p>
<p>与此同时，还需要注意一个过拟合的问题：</p>
<ul>
<li>
<p>这个可以用线性回归模型来进行演示，在平面上的那么多个点，划出一条直线，那么这一条直线是不可能都刚好通过所有的点的，假如说真的有那么一条直线通过所有的点，那么说明问题大了，为了通过所有的点，往往就付出了准确性下降，无法正确预测后面的点的代价，这个就是过拟合。</p>
</li>
<li>
<p>一般情况下，预测的正确性能够有80%-90%就挺不错的了，太高就会发生过拟合问题，太低那就是预测不准。</p>
</li>
</ul>
<blockquote>
<p>现在研究完了SVM向量机，那么它是如何快速处理那么多的数据的呢？</p>
</blockquote>
<p>这必须要用到加速处理。</p>
<h1 id="将低维非线性升为高维线性函数"><a class="markdownIt-Anchor" href="#将低维非线性升为高维线性函数"></a> 将低维非线性升为高维线性函数</h1>
<p>高维线性函数可以使用线性回归方程求解，进而优化计算速度。</p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>大一下学期第三周</title>
    <url>/2024/03/22/%E5%A4%A7%E4%B8%80%E4%B8%8B%E5%AD%A6%E6%9C%9F%E7%AC%AC%E4%B8%89%E5%91%A8/</url>
    <content><![CDATA[<h1 id="first"><a class="markdownIt-Anchor" href="#first"></a> first</h1>
<p>这个星期……首先是真的手贱。</p>
<p>之前调好的git方案，然后手贱g了一下，刷没了。</p>
<p>然后重新折腾……结果也没折腾出来，我也忘记当时是怎么搞得了。</p>
<p>所以……暂时就不管了。</p>
<p>反正腾讯云的站点就手动更新一下就可以了费不了多少功夫。</p>
<p>然后，我准备等到11月份，这一台服务器到期之后，就改用腾讯云的静态网页托管的方案，能便宜一点。</p>
<p>之前已经试过了，买了一个月的，如果你现在要访问，<span class="exturl" data-url="aHR0cDovL2Jsb2cubW9venkuc3BhY2U=">静态网页托管站<i class="fa fa-external-link-alt"></i></span>，可以点进去试试。</p>
<p>然后如果你是在五月份或者更后的时间看见这一篇博客的话，那此时上面的网址已经无法打开了，等到11月份这个服务器过期我再给静态网页托管进行续费。</p>
<p>这是让人无语的事情。</p>
<p>然后除此之外，还有没有别的什么事情呢？</p>
<p>当然也是有的。</p>
<h2 id="first-plus"><a class="markdownIt-Anchor" href="#first-plus"></a> first-plus</h2>
<p>今天星期五，上面的内容是昨天写的。</p>
<p>我忽然想到，我为什么不干脆连静态网页托管也取消掉呢……我这样做是有一点心疼的，因为报审核也花了我不少精力。</p>
<p>但是……一个月15块也挺贵的。</p>
<p>但是报审核，只是等待的时间比较久，实际操作并不复杂，而且估计最近好几年内github都不会放弃github page业务……</p>
<p>这着实是一件让人犹豫的事情。</p>
<p>所以就先这么做吧。</p>
<p><strong>提前向我开了半年的网站说再见</strong></p>
<p>我计划将整个网站都完全托管在Github Page上，在可见的未来内不再犹豫。</p>
<h1 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2</h1>
<p>我之前曾经看过《怪兽屋》、《机械心》、《自杀专卖店》这几部电影。我还记得当时是在万圣节附近，是在电视猫里面的一个万圣节专场免费看电影的活动里看的。</p>
<p>这几部电影名字看起来十分惊悚，画风也非常诡异，但是其实是十分好看的电影，别有一番风味。</p>
<h1 id="3"><a class="markdownIt-Anchor" href="#3"></a> 3</h1>
<p>这周被模电给虐杀了。</p>
<p>很难讲模电难不难，但是确实是不简单的。</p>
<p>I will keep work for it.</p>
<h1 id="4"><a class="markdownIt-Anchor" href="#4"></a> 4</h1>
<p>现在已经是第四周的周一了，现在再来为第三周做一些补充吧。</p>
<h2 id="关于模电"><a class="markdownIt-Anchor" href="#关于模电"></a> 关于模电</h2>
<p>第三周周末花了好几个小时来学模电，然后终于似乎是懂得了一些，什么运放，基础放大电路、反相运算、加法减法运算……</p>
<p>但是感觉花的时间还是不够多，主要体现在很多电路的特点都没有记下来。</p>
<p>现如今第四周开始上前面的PN结的内容了，但是后面的运放我还是要花时间去看看，毕竟……没有几周就到期中考试了。</p>
<h2 id="关于数学"><a class="markdownIt-Anchor" href="#关于数学"></a> 关于数学</h2>
<p>数学也有点难。</p>
<p>但是嘛，难度还好，主要是有一点抽象，计算有点复杂，要花一点心思，但是做题实际上是不难的。</p>
<h2 id="关于消费"><a class="markdownIt-Anchor" href="#关于消费"></a> 关于消费</h2>
<p>决定从这周开始不再每天一瓶可乐和雪碧，这样每天都可以节省3块钱。</p>
<p>有点想买一台电脑，主要是现在这一台电脑到处搬着走确实不重，但是也是要费一点功夫，我期望能买一台十分轻薄的笔记本，方便我到处行走，编写文档，上上浏览器。</p>
<p>但是这……确实也不是必须的，我等着看以后有没有什么优惠吧，我可能会去买一台华为的mate book e，平板式的笔记本，足够轻薄，而且价格尚可，而且本来就是为了编写文档于与浏览器，就相当于上网本一样使用，也就不需要怎么样的性能支持。</p>
<h2 id="关于比赛"><a class="markdownIt-Anchor" href="#关于比赛"></a> 关于比赛</h2>
<p>这个学期和学长们一起去打嵌入式比赛，昨天学长问我对于比赛项目有什么想法，我表示支持他的一切想法，于是他说我们做机械臂。</p>
<p>好的，那么就做机械臂。</p>
<p><strong>唯一需要注意的事情是安全问题。<strong>我对于所有的电子、机械、工厂都心存敬畏，因为这些玩意是真能要了你的命，而且我们都是半桶水的技术，假如不小心，那么出安全问题的可能性更大，所以</strong>一定要注意安全</strong>，安全才是最重要的。平平安安出门去，平平安安回家来。</p>
]]></content>
      <categories>
        <category>周记</category>
      </categories>
  </entry>
  <entry>
    <title>随便说说</title>
    <url>/2024/03/26/%E9%9A%8F%E4%BE%BF%E8%AF%B4%E8%AF%B4/</url>
    <content><![CDATA[<p>上周考完计算机二级。</p>
<p>感觉难度尚可,算不上是什么难事。</p>
<p>不过确实有一些担心我的考试不过。</p>
<p>这两天都在忙活一件小事，那就是用STM32的hal库来搞一个数码管显示数字。</p>
<p>但是前天实现了段选，但是位选却一直没有搞定。</p>
<p>说到底，就是对于hal库不太了解，而原本学习的标准库有段时间没看，也差不多快要忘了。</p>
<p>这两天花了不少时间在各个平台和网站上找资料，很让人沮丧的是，基本上找不到什么有用的资源，说起来搞笑的是，今天晚上在知乎搜索hal库 位选，结果找出来了一个人对大部分hal库文件的注释的汉化的文章。</p>
<p>这样的文章没有用吗？很难讲，我觉得是十分有用的，对于初学者来讲，中文可以显著降低他们对hal库以及官方文档的恐惧感。</p>
<p>可是这样的文章却只有十几个观看。</p>
<p>而更多的搜索出现的几千乃至几万个观看的文章呢？却顾左右而言它，基本上没有什么软用。</p>
<p>今天晚上，索取无路，于是决定摆烂，很干脆地问了文心一言如何使用GPIO 的 PB引脚，很快，文心一言给出了答案。</p>
<p>HAL_GPIO_WritePin(GPIOB,GPIO_PIN_0,GPIO_PIN_SET)</p>
<p>我可以这么说：一语惊醒梦中人。</p>
<p>我忽然意识到前面的GPIOB、GPIOA到底是什么意思了，而我之前在百度和知乎上搜索却告诉我说是区分什么虚拟、物理串口用的。好吧，也不能说完全没有，只能说对于我一个寻求资料的人来讲没有什么软用。</p>
<p>于是，终于，我实现了段选与位选。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_GPIO_WritePin(GPIOA,num_code[<span class="number">3</span>],GPIO_PIN_SET);</span><br><span class="line">		HAL_GPIO_WritePin(GPIOB,GPIO_PIN_5,GPIO_PIN_SET);</span><br><span class="line">		HAL_GPIO_WritePin(GPIOB,GPIO_PIN_4,GPIO_PIN_RESET);</span><br><span class="line">		HAL_GPIO_WritePin(GPIOB,GPIO_PIN_3,GPIO_PIN_RESET);</span><br><span class="line">		HAL_Delay(<span class="number">500</span>);</span><br><span class="line">		HAL_GPIO_WritePin(GPIOA,num_code[<span class="number">3</span>],GPIO_PIN_RESET);</span><br><span class="line">		HAL_Delay(<span class="number">500</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_3070——前缀和</title>
    <url>/2024/03/19/leetcode-3070/</url>
    <content><![CDATA[<p><strong>元素和小于等于 k 的子矩阵的数目</strong></p>
<h1 id="前缀和"><a class="markdownIt-Anchor" href="#前缀和"></a> 前缀和</h1>
<p>为什么要使用前缀和的方式来写代码？</p>
<p>首先，当然，你可以暴力遍历，由于要求矩阵的元素和的数目，你可以依次先遍历横行，然后再遍历竖行，两个for循环应该就可以搞定。</p>
<p>但是请注意，这样的做法可能无法通过leetcode等软件的测试，因为这样的计算要花费很长的时间。</p>
<blockquote>
<p>我向来不相信知乎上有的人说自己用python多快多快，但是用C<ins>来运行代码就十分慢。<br />
不正是这么一回事么，自己没写好代码，python上许多的库的质量都非常好，所以python运行起来速度也不慢，但是C</ins>上你自己写的函数可不就是能用就行。</p>
</blockquote>
<p>所以我们应该如何优化我们的代码？</p>
<p>我们可以注意到，当使用for循环计算的时候，出现了很多重复次数的计算，我们应该避免这些重复计算。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubmatrices</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>,m = grid.<span class="built_in">size</span>(),n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sum</span> (m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                sum[i+<span class="number">1</span>][j+<span class="number">1</span>] = sum[i+<span class="number">1</span>][j] + sum[i][j+<span class="number">1</span>] -sum[i][j] + grid[i][j];</span><br><span class="line">                ans += sum[i+<span class="number">1</span>][j+<span class="number">1</span>]&lt;=k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>vector&lt;vector&lt;int&gt;&gt; sum (m+1,vector&lt;int&gt;(n+1));</code>先是生成一个答案容器，用来储存数据。</p>
<p>这里需要注意要多申请一点空间，也就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，方便用来数据初始化。</p>
<p>然后进行计算。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\begin{bmatrix} 
1 &amp; 2 \\
2 &amp; 3 \end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span> 类似于这样的一个数组，我们怎么给他进行sum求和？</p>
<p>凭借经验，我们很快可以得到这样的一个结果：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>8</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\begin{bmatrix} 
1 &amp; 3 \\
3 &amp; 8 \end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span> ，那我们是怎么样做的呢？最开始的1，我们不做任何处理，然后右上的2，我们给他加上左边的1，左下的2也是同理，对于右下的3，可以这样抽象，正如左下的2一样，可以给他加上右上的3，然后左边同理，再加上一个3.此时我们可以注意到，1重复了，那么我们就把1给减掉。</p>
<p><code>sum[i+1][j+1] = sum[i+1][j] + sum[i][j+1] -sum[i][j] + grid[i][j];</code></p>
<p>于是我们就得到了这样的式子。</p>
<p>如果sum[i+1][j+1]符合&lt;=k的条件，那么就说明以grid左上元素到[i][j]这个矩阵的和符合条件。</p>
<p>如此，通过前缀和，我们就实现了对于计算的简化。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第四周</title>
    <url>/2024/04/03/%E7%AC%AC%E5%9B%9B%E5%91%A8/</url>
    <content><![CDATA[<p>现在已经是到了第五周的一半了。上一周没有写周记，这一周补上。</p>
<p>我忽然感到有些许伤心。</p>
<p>这个学期的八月份，有一场物联网比赛，分校区比赛一直到8月20号，总决赛一直到30号。</p>
<p>假如说没有进入分赛区决赛，可以10号回家，假如进入了分决赛，那么就要20号回家，假如进入了总决赛，那么就要到30号。</p>
<p>我忽然就开始想念起我的家里人了。</p>
<p>上一周，一切都还好，都还不错。一切都在稳中向好。再过上六十多天就要考英语四级了，希望可以过。</p>
<p>下周就到了蓝桥杯比赛的日子。</p>
<p>希望可以拿一个省三回来，节约一点开支，挣一点奖学金。</p>
]]></content>
      <categories>
        <category>周记</category>
      </categories>
  </entry>
  <entry>
    <title>第五周</title>
    <url>/2024/04/07/%E7%AC%AC%E4%BA%94%E5%91%A8/</url>
    <content><![CDATA[<h1 id="这周没什么可说的"><a class="markdownIt-Anchor" href="#这周没什么可说的"></a> 这周没什么可说的</h1>
<p>今天是星期日的晚上，明天就是第六周了。</p>
<p>当我写第四周的周记的时候，其实已经到了第四周的周三，这一周是清明小长假，这周，我花了一点时间去看数学建模，看了一点算法。</p>
<p>下周周六早上九点就要考蓝桥杯了，我其实还什么都不懂。</p>
<p>我恐怕是要浪费那300块钱了。</p>
<p>不过如果能拿到奖也算是一件幸事。</p>
<p>最大的问题，最大的问题，还是那一点，焦虑感压着你喘不过气，正是这种焦虑感，你不可能去高效率处理什么问题，总是想着如果干不成怎么办，就在这样的日子中把时间一点点空耗掉。</p>
<p>除此之外，也正是这样的行为所带来的副作用，使用手机查阅资料，学习的时候总是不自觉就开始刷视频。</p>
<p>这毫无疑问是一种极其坏的习惯，是极其不好的。</p>
<p>当你正在学习，思考的时候，突然开始看起来视频固然很不错，但是与此同时你也要注意到，这样的娱乐行为会让你的大脑分泌过量的兴奋剂，不但使得原来的学习状态被打破，还使得你后续很难再进入学习状态。</p>
<p>这是一种极其害人的玩意，你必须彻底做一个了断。</p>
<p>按照这样的思路回想过去，我也曾经浪费了不少的时间。</p>
<p>在会看起现在的日子。</p>
<p><strong>游戏固然可以玩，视频固然可以刷</strong>，但是凡事都要讲究一个限度，你应该做什么事情的时候，你就应该去做什么事情，而不是将两者混为一谈，而不是任由你的多巴胺控制你的行为。</p>
<p>一个人的时间是有限的，精力也是有限的，良好的学习时间也是有限的（此外进行一个补充：无用的仪式感——比如说整点开始你的行动——也是一种浪费时间的玩意。你有时间，就应该立即去做下一件事，而不是还差上十几分钟，于是先玩一会手机再去干事！）</p>
<p><em><strong>我决定从第六周开始挽回过去的错误。</strong></em></p>
]]></content>
      <categories>
        <category>周记</category>
      </categories>
      <tags>
        <tag>周记</tag>
      </tags>
  </entry>
  <entry>
    <title>learn_F#</title>
    <url>/2024/03/29/learn-F/</url>
    <content><![CDATA[<h1 id="什么是f"><a class="markdownIt-Anchor" href="#什么是f"></a> 什么是F#？</h1>
<p>F#是一门同样基于.net生态的语言，在某方面来讲，它与C#十分相似。</p>
<p>它与C#最大的不同，就是F#具有浓重的函数式思想，而C#则更多面向对象。</p>
<p>所有C#可以做的事情，F#都可以完成，区别只是要花费的精力有所不同。</p>
<figure class="highlight f#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// For more information see https://aka.ms/fsharp-console-apps</span></span><br><span class="line"><span class="built_in">printfn</span> <span class="string">&quot;Hello from F#&quot;</span></span><br><span class="line"><span class="keyword">open</span> System <span class="comment">// Gets access to functionality in System namespace.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Defines a list of names</span></span><br><span class="line"><span class="keyword">let</span> names <span class="operator">=</span> [ <span class="string">&quot;Peter&quot;</span>; <span class="string">&quot;Julia&quot;</span>; <span class="string">&quot;Xi&quot;</span> ]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Defines a function that takes a name and produces a greeting.</span></span><br><span class="line"><span class="keyword">let</span> getGreeting name <span class="operator">=</span> <span class="string">$&quot;Hello, <span class="subst">&#123;name&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Prints a greeting for each name!</span></span><br><span class="line">names</span><br><span class="line"><span class="operator">|&gt;</span> List.map getGreeting</span><br><span class="line"><span class="operator">|&gt;</span> List.iter (<span class="keyword">fun</span> greeting <span class="operator">-&gt;</span> <span class="built_in">printfn</span> <span class="string">$&quot;<span class="subst">&#123;greeting&#125;</span>! Enjoy your F#&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cnt <span class="operator">=</span> <span class="number">1</span> <span class="keyword">to</span> <span class="number">12</span> <span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">printf</span> <span class="string">$&quot;nice to see you ,<span class="subst">&#123;cnt&#125;</span> \n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mutable</span> cnt <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//F#中let默认生成的值是自动绑定的，也就是不可变值，假如想要让let的值可变，那么就用mutable属性来修饰。</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">do</span> </span><br><span class="line">    cnt <span class="operator">&lt;-</span> cnt <span class="operator">+</span> <span class="number">1</span> </span><br><span class="line">    <span class="built_in">printfn</span> <span class="string">$&quot;hello ,No.<span class="subst">&#123;cnt&#125;</span> Are you <span class="subst">&#123;name&#125;</span>?&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>wiki</category>
        <category>F#</category>
      </categories>
  </entry>
  <entry>
    <title>第六周</title>
    <url>/2024/04/11/%E7%AC%AC%E5%85%AD%E5%91%A8/</url>
    <content><![CDATA[<h1 id="first"><a class="markdownIt-Anchor" href="#first"></a> First</h1>
<p>说起来愧疚，今天上学期的C语言老师认出我来了，并且问我蓝桥杯备战怎么样。</p>
<p>我该怎么说呢……虽然已经是见识了不少题，做了不少笔记，类似于什么vector,unordered_map,unordered_set都能用一用，但是其实水平还是很低。</p>
<p>回望我的过去的日子。</p>
<p>我突然发现，我的学习能力比起我高一，甚至高三的时候要差远了。</p>
<blockquote>
<p>这里的学习能力指的是接受新事物，并且记忆，并且学会运用的能力。</p>
</blockquote>
<p>这毫无疑问是一种打击。</p>
<p>现如今，我对于蓝桥杯，实在是心里没底，我还能做什么呢？我也不知道。</p>
<h1 id="second"><a class="markdownIt-Anchor" href="#second"></a> Second</h1>
<p>这一周是确确实实比起上一周使用手机少了。</p>
<p>上课也更加认真了。</p>
<p>但是我终究是浪费了时间，而且最大的问题在于，手机对于一个人的学习习惯的伤害是很大的。</p>
<p>这是一种手机所带来的害处。</p>
<p>所以我很早就认为，假如小时候没有正确学会如何对待手机，等到长大了也不会知道应该如何对待手机。</p>
<h1 id="3"><a class="markdownIt-Anchor" href="#3"></a> 3</h1>
<p>我很喜欢使用火狐，但是不代表火狐的使用体验好。</p>
<p>火狐其实质上和edge、谷歌比起来已经落伍了。</p>
<p>但是火狐标志着自由与造反，所以我才喜欢使用火狐而已。</p>
]]></content>
      <categories>
        <category>周记</category>
      </categories>
      <tags>
        <tag>周记</tag>
      </tags>
  </entry>
  <entry>
    <title>曼哈顿与切比雪夫</title>
    <url>/2024/04/05/%E6%9B%BC%E5%93%88%E9%A1%BF%E4%B8%8E%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB/</url>
    <content><![CDATA[<h1 id="曼哈顿坐标系与切比雪夫坐标系的适用范围"><a class="markdownIt-Anchor" href="#曼哈顿坐标系与切比雪夫坐标系的适用范围"></a> 曼哈顿坐标系与切比雪夫坐标系的适用范围</h1>
<p><strong>曼哈顿坐标系通常适用于计算两点在标准坐标系中的绝对距离</strong>，特别是在涉及网格或像素的场景中。由于曼哈顿距离考虑的是各个维度上的差值之和，它非常适合描述在像素或网格构成的空间中从一个点到另一个点的移动路径。例如，在计算机图形学中，屏幕是由像素构成的，而点的坐标也通常是整数，这使得曼哈顿距离成为一种非常自然的距离度量方式。此外，曼哈顿距离在仓库物流等领域也有应用，因为它可以用来表示在网格状布局中从一个位置到另一个位置的实际移动距离。</p>
<p>而<strong>切比雪夫坐标系则通常用于衡量两个向量在各个维度上的最大差值</strong>，或者可以理解为沿着一个坐标轴的最大距离。由于其本质，切比雪夫距离通常被称为棋盘距离，因为国王从一个方格到另一个方格的最小步数等于切比雪夫距离。切比雪夫距离在特定情况下非常有用，例如在游戏中提取从一个方块到另一个方块所需的最小步数，或者在允许无限制的8向移动的游戏中作为衡量移动距离的指标。此外，切比雪夫距离在仓库物流中也有应用，因为它可以很好地模拟起重机在移动物体时的路径。</p>
<p>如何将曼哈顿坐标系转化为切比雪夫坐标系？</p>
<p>对于一个在标准坐标系的点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>，其对应的切比雪夫坐标系的值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mfrac><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow><mn>2</mn></mfrac><mo separator="true">,</mo><mfrac><mrow><mi>x</mi><mo>−</mo><mi>y</mi></mrow><mn>2</mn></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\frac{x+y}{2},\frac{x-y}{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.199439em;vertical-align:-0.345em;"></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854439em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854439em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>元件</title>
    <url>/2024/04/14/%E5%85%83%E4%BB%B6/</url>
    <content><![CDATA[<p>对于元件，有时候会有需要自己画元件的时候。</p>
]]></content>
      <categories>
        <category>电路</category>
        <category>硬件</category>
      </categories>
  </entry>
  <entry>
    <title>第八&amp;九周</title>
    <url>/2024/05/02/%E7%AC%AC%E5%85%AB-%E4%B9%9D%E5%91%A8/</url>
    <content><![CDATA[<p>假如下一年服务器续费的价格也还是175元的话，那么其实还不如去续费服务器。</p>
<p>现在我暂时没有办法快速把本地地更改同步到我的服务器上，之前没有问题，但是自从我修改了服务器上的公布文件夹，一切就无法正常运行了。</p>
<p>现在我也没有什么精力去维护这些东西了，如今深陷ESP32、数学建模、模电之中了</p>
]]></content>
      <categories>
        <category>周记</category>
      </categories>
      <tags>
        <tag>周记</tag>
      </tags>
  </entry>
  <entry>
    <title>第七周</title>
    <url>/2024/04/15/%E7%AC%AC%E4%B8%83%E5%91%A8/</url>
    <content><![CDATA[<h1 id="上周"><a class="markdownIt-Anchor" href="#上周"></a> 上周</h1>
<p>上一周考完了蓝桥杯，感觉其实难度尚可。只不过有的题目确实是经验不足。</p>
<p>这一周我打算开始努力学习模电，然后为那几个比赛做一些准备。</p>
]]></content>
      <categories>
        <category>周记</category>
      </categories>
  </entry>
  <entry>
    <title>第十一周</title>
    <url>/2024/05/18/%E7%AC%AC%E5%8D%81%E4%B8%80%E5%91%A8/</url>
    <content><![CDATA[<h2 id="fist"><a class="markdownIt-Anchor" href="#fist"></a> Fist</h2>
<p>之前曾经说过的esp32现在看来已经不是什么问题了。</p>
<p>arduino开发带来的优势是难以言表的，上面有非常多的设备库，假设这些库的导入不会带来什么病毒与错误，在他们正常运行的情况下，只需要短短几行代码就可以实现一个原本实现起来十分复杂的目标。</p>
<p>模电倒是确实是一个问题。</p>
<p>不过我已经填补了很大一部分的空缺，还有一些残余，但是一切似乎看起来都在正面向好。</p>
<p>个人博客最大的问题就是没有人看。</p>
<p>这个就是最大的问题。</p>
<p>我在努力让我的博客有价值。</p>
]]></content>
      <categories>
        <category>周记</category>
      </categories>
      <tags>
        <tag>周记</tag>
      </tags>
  </entry>
  <entry>
    <title>近代史提纲</title>
    <url>/2024/05/30/%E8%BF%91%E4%BB%A3%E5%8F%B2%E6%8F%90%E7%BA%B2/</url>
    <content><![CDATA[<p>1.鸦片战争是中国近代史的起点</p>
<p>2.鸦片战争以后，独立的中国逐步变成半殖民地的中国，封建的中国逐步变成半封建的中国，原因外国资本主义帝国主义列强，用武力打开中国的门户，把中国卷入世界资本主义经济体系和市场之中</p>
<p>3.西方列强对中国的侵略，包括军事侵略，政治控制，经济掠夺，文化渗透<br />
4.太平天国定都天津颁布天朝田亩制度，建立有“有田同耕，有饭同食，有衣同穿，有钱同使，无处不均匀，无人不保暖”的理想社会。</p>
<p>5.洋务运动的代表人物。奕䜣，曾国藩，李鸿章，左宗棠，张之洞</p>
<p>6.维新派与守旧派的论战包括三个方面：第一，要不要变法，第二，要不要新民权设议院实行君主立宪，要不要废八股改科举和兴西学。</p>
<p>7.陈天华写了《警世钟》和《猛回头》，两本小册子</p>
<p>8.孙中山将同盟会的纲领概括为三大主义，民族主义，民权主义，民生主义，称为三民主义。</p>
<p>9.自己总结新文化运动的兴起和意义（91-93）页。</p>
<p>10.辛亥革命的历史意义：第一，辛亥革命推翻了封建势力的政治代表，帝国主义在中国的代理人清王朝的统治，沉重打击了中外反动势力，使中国反动统治者在政治上乱了阵脚。第二，辛亥革命结束了中国延续2000多年的君主专制制度，建立了中国历史上第一个资产阶级共和政府，使民主共和的观念开始深入人心，并在中国形成了“敢有帝制自为者，天下共击之”的民主主义观念。第三，辛亥革命，推动了中国人民的思想解放。第四，辛亥革命推动了中国的社会变革，促使中国的社会经济思想习惯和社会风俗等方面发生了积极的变化，第五，辛亥革命不仅在一定程度上打击了帝国主义的侵略势力，而且推动了亚洲各国民族解放运动的高潮</p>
<p>11.新文化运动提倡民主和科学，民主即是资本主义民主、科学指广义上的社会科学。</p>
<p>12.中国共产党成立的历史意义：深刻改变了近代以后中华民族发展的方向和进程、深刻改变了中国人民和中华民族的前途和命运、深刻改变了世界发展的趋势与格局。</p>
<p>13.国民党一大事实上确认了联俄联共扶助农工的三大革命政策，标志着第一次国共合作正式形成。</p>
<p>14.1924年至1927年，中国反帝反封建革命比以往任何一次革命，包括辛亥革命和五四运动，一、群众的动员程度更加广泛。二、斗争的规模更加宏伟。三、革命的社会内涵更为深刻，因此被称作大革命</p>
<p>15.一、大革命是在反对帝国主义，反对军军阀的政治口号下进行的，而提出这一口号的正是中国共产党。二、大革命是在以国共合作为基础的统一战线的组织形式下进行的，而中国共产党正是国共合作的倡导者和统一战线的组织者。三、大革命是近代中国历史上空前广泛而深刻的群众运动，而中国共产党正是人民群众的主要发动者和组织者，是大革命的主要行斗争形式，是革命战争由中国共产党直接领导的第四军独立团，是一个突出的例证。</p>
<p>16.“八七会议”确立了土地革命和武装起义的方针。</p>
<p>17.“三湾改编”是建设无产阶级领导的新型人民军队的重要开端。</p>
<p>18.“古田会议”的主要内容：一、确立了思想建党，政治建军的原则。二、阐述了加强党的思想建设的极端重要性，指明党内各种非无产阶级思想的表现来源及纠正办法。三、规定红军是一个执行革命的政治任务的武装集团，必须绝对服从共产党的领导，必须全心全意为党的纲领，路线和政策而奋斗。四、提出红军必须担负打仗筹款和做群众工作任务的任务，必须加强政治工作。</p>
<p>19.“遵义会议”。事实上，确立了毛泽东在党中央和红军的领导地位，开始形成以毛泽东同志为核心的第一代中央领导集体。</p>
<p>20.1931年9月18日“九一八事变”日本变中国为其独占殖民地的侵略战争由此开始</p>
<p>21.1937年7月7日，“卢沟桥事变”即“七七事变”，标志着日本全面侵华战争由此开始</p>
<p>22.抗日战争中的中流砥柱。一、全面抗战路线和持久战的战略总方针。二、敌后战场的开辟与游击战争的发展。三、坚持抗战，团结，进步的方针。四、抗日民主根据地的建设，五、大后方的抗日民主运动和进步文化工作。六、中国共产党的自身建设</p>
<p>23.中共七大标志着党在政治上，思想上，组织上走向成熟。他为建立新民主主义的新中国制定了正确路线方针政策，确立了毛泽东在党中央和全党的领导核心地位。毛泽东思想在全党的指导地位，形成了一支高举毛泽东旗帜的经久考验的政治家集团。</p>
<p>24.延安精神。中国共产党形成了以坚定正确的政治方向、解放思想，实事求是的思想路线，全心全意为人民服务的根本宗旨，自力更生，艰苦奋斗的创业精神为主要内容的延安精神。这是党的宝贵精神财富</p>
<p>25.抗日战争胜利的原因，第一，以爱国主义为核心的民族精神是中国人民抗日战争胜利的决定因素。第二，中国共产党的中流砥柱作用是中国人民抗日战争胜利的关键。中国共产党自成立之日起，就把实现中华民族伟大复兴作为自己的历史使命。第三，全民族抗战是中国人民抗日战争胜利的重要法宝。中国共产党坚持动员人民，依靠人民，推动形成了全民族抗战的历史洪流，第四，中国人民抗日战争的胜利同世界所有爱好和平和正义的国家和人民。国际组织以及各种反法西斯力量的同情和支持，也是分不开的</p>
<p>26.重庆谈判确立双十协定确认和平建国的基本方针</p>
<p>27.国民党统治区的政治经济危机表现。一，国民党政府由于其专制独裁统治和官员们的贪污腐败大发国难财，抗战后期在大后方便，已严重丧失人心。二、国民党之所以迅速失去民心，主要是由于它违背全国人民迫切要求休养生息，和平建国的意愿，执行反人民的内战政策。三、官僚资本主义极度膨胀工农业生产严重萎缩，大批民族工商业濒于倒闭</p>
<p>28.毛泽东思想活的灵魂：一、实事求是二、群众路线三、独立自主</p>
<p>29.毛泽东指出，战胜敌人的三个法宝：统一战线、武装斗争、党的建设</p>
<p>30.捍卫巩固新政权的斗争。一，完成民主革命的遗留任务。二，巩固民族独立，维护国家主权和安全。三，抗美援朝，保家卫国，四，恢复国民经济为社会主义改造创造条件</p>
<p>31.三反运动，反贪污，反浪费，反官僚主义</p>
<p>32.社会主义基本制度确立的伟大意义，社会主义基本制度的确立，极大地提高了工人阶级和广大劳动人民的积极性，创造性，为社会生产力的大发展开辟了广阔道路，二，社会主义基本制度的确立，为当代中国的一切发展进步提供了根本政治保障，三，社会主义基本制度的确立，为社会主义先进文化的发展指明了前进方向，四，社会主义制度的确立，标志着中国这个占世界1/4人口的东方大国进入了社会主义社会</p>
<p>33.1957年二月，毛泽东发表《关于正确处理人民内部矛盾问题的讲话》，意义在马克思主义发展史上具有开创性意义。毛泽东深入研究社会主义社会的矛盾问题，形成一套系统的关于社会主义社会矛盾的学说</p>
<p>34.1964年底，周恩来在三届全国人大一次会议上，郑重提出实现四个现代化的历史任务，四个现代化，包括现代农业，现代工业，现代国防和现代科学技术</p>
<p>35.1971年十月25日，第26届联大通过2758号决议，决定恢复中华人民共和国在联合国的一切合法权利</p>
<p>36.邓小平在中央工作会议闭幕会上作题为 <strong>《解放思想，实事求是，团结一致向前看》</strong> 的讲话，这个讲话是解放思想，开辟新时期新道路的宣言书</p>
<p>37.邓小平南方谈话明确提出，使用社会主义市场经济体制这个提法，为中共14大召开做了重要的思想理论准备</p>
<p>38.党的二十大高度评价了新时代十年的伟大变革。大会指出，党的十八大召开十年来，我们经历了对党和人民事业具有重大现实意义和深远历史意义的三件大事：一是迎来中国共产党成立一百周年，二、是中国特色社会主义进入新时代，三、是完成脱贫攻坚、全面建成小康社会的历史任务，实现第一个百年目标。</p>
<p>39.两个确立：确立习近平同志党中央的核心、全党的核心地位，确立习近平新时代中国特色社会主义思想的指导地位。1.反映了全党全军全国各族人民共同心愿，对新时代党和国家事业发展具有决定性意义2.对推进中华民族伟大复兴历史进程具有决定性意义。3.新时代新征程上把中国特色社会主义事业推向前进。</p>
<p>40.中国式现代化的本质要求：坚持中国公产党的领导，坚持中国特色社会主义，实现高质量发展，发展全过程人民民主，丰富人民精神世界，实现全国人民共同富裕，促进人与自然和谐共生，推动构建人类命运共同体，创造人类文明新形态。</p>
<p>41.2035年到本世纪中叶把我国建设成富强民主文明和谐美丽的社会主义现代化强国。</p>
<p>42.两个务必：务必对同志保持谦虚、谨慎、不骄、不躁的作风；务必使同志们继续地保持艰苦奋斗的作风。新时代三个务必：1.务必不忘初心，牢记使命。2.务必谦虚谨慎，艰苦奋斗。3.务必敢于斗争，善于斗争</p>
<p>43.中国式现代化的本质要求是：坚持中国共产党领导，坚持中国特色社会主义，实现高质量发展，发展全过程人民民主，丰富人民精神世界，实现全体人民共同富裕，促进人与自然和谐共生，推动构建人类命运共同体，创造人类文明新形态。</p>
]]></content>
  </entry>
  <entry>
    <title>写于24年7月2日</title>
    <url>/2024/07/02/%E5%86%99%E4%BA%8E24%E5%B9%B47%E6%9C%882%E6%97%A5/</url>
    <content><![CDATA[<h1 id="写于7月2日"><a class="markdownIt-Anchor" href="#写于7月2日"></a> 写于7月2日</h1>
<h2 id="今日是7月4日"><a class="markdownIt-Anchor" href="#今日是7月4日"></a> 今日是7月4日</h2>
<p>看起来是一个笑话，但是其实是这样的，其实周记的题目的时间也不是非得要和实际的时间匹配起来是吧？</p>
<p>现在我又遇到了一件十分烦心的事情，我这个学期考的不咋地，还有一些学科的成绩没有出来，但是……想来也不会是很好。</p>
<p>仔细想想这个学期你都做了些什么呢？你花了一些时间来打一个蓝桥杯，拿到了一个省二，这固然很好，然后是你的嵌赛，你的物联网设计大赛。经过这些磨练，你对于软件构建更加顺手了，你学过了avalonia，MAUI,flutter,最终选择了使用MAUI来构建你的那一个MQTT软件。目前的成果是：最终可以实现了配网，让其可用。</p>
<p>这个学期对于python也有了深入的研究，对于python的了解也不错了。知道那一些python的基础库是如何使用的，至少能成为一个有点水平的调包侠了。</p>
<p>再然后呢？这样说固然不是很好，但是……这些东西都是有一个十分关键的错误的，那就是这些是不可太持续的，是属于未来的布局，而其变现的时间遥遥无期，等到其终于迎来变现的时机的时候，你难道真的可以把握住吗？</p>
<p>你在高三的时候学了基础的Python语法，但是当你到大一的时候，你就完全忘记了，你甚至不确定Print是如何使用的。那么你现在大一所取得的成绩到了大四，你还剩下什么呢？</p>
<p>然后，作为一个通信工程的学生，你的大部分时间都要花在硬件上，但是与其所对应的模电你却学得一塌糊涂。那么说回考研，你的英语有学的什么样？你的数学又学得怎么样？你固然可以以现在学会了，到时候会忘作为借口，但是这是基础，有了基础，你能学得更快。</p>
<p>或许……</p>
<p>根本的问题是：我对于自己确实有很高的要求，我不希望这样的人生再持续下去。当你进入高中的时候，你自以为自己很有希望去冲刺一个北京理工大学，你自以为自己能够在3年的时间里面逆天改命，但是事实就是，你比起初三的时候的自己差远了，你整个高中三年都做了什么，你自己的心里清楚，最终来到防灾科技学院，你是什么实力你自己的心里也有数，一个二本，你也就是这样的水平。</p>
<p>不论你怎么自视甚高，不论你如何狡辩，事实就是事实，你就是来到了防灾科技学院，然后更进一步的，在这里如此简单的期末的试卷的威胁下，你甚至几乎擦着及格的边。</p>
<p>你是什么水平呢？</p>
]]></content>
      <categories>
        <category>周记</category>
      </categories>
      <tags>
        <tag>周记</tag>
      </tags>
  </entry>
  <entry>
    <title>数学建模</title>
    <url>/2024/05/26/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/</url>
    <content><![CDATA[<p>这段代码主要是用于计算一个食谱中各种食物所含的蛋白质总量以及一个叫做“总氨基酸评分”的指标。以下是对这段代码的详细解释：</p>
<ol>
<li><strong>初始化变量</strong>:</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total_protein = <span class="number">0</span></span><br><span class="line">total_amino_acid_scores = &#123;&#125;</span><br></pre></td></tr></table></figure>
<pre><code>* `total_protein` 用于记录整个食谱中的蛋白质总量。
* `total_amino_acid_scores` 是一个字典，用于记录每种氨基酸的评分总和。
</code></pre>
<ol start="2">
<li><strong>遍历食谱</strong>:</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> foods <span class="keyword">in</span> recipe.values():</span><br></pre></td></tr></table></figure>
<p>这里假设 <code>recipe</code> 是一个字典，其值是一个嵌套的字典。外部循环遍历 <code>recipe</code> 字典中的所有值（也就是食物列表）。<br />
3. <strong>处理每种食物</strong>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> food, (amount, servings) <span class="keyword">in</span> foods.items():</span><br></pre></td></tr></table></figure>
<p>对于每种食物，我们获取其名称（<code>food</code>）、数量（<code>amount</code>，可能是以克为单位）和服务的份数（<code>servings</code>）。<br />
4. <strong>计算蛋白质总量</strong>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total_protein += nutrient_content_per_100g[food].get(<span class="string">&#x27;蛋白质&#x27;</span>, <span class="number">0</span>) * (amount / <span class="number">100</span>) * servings</span><br></pre></td></tr></table></figure>
<pre><code>* `nutrient_content_per_100g` 是一个外部字典，它应该包含每种食物每100克的营养成分。
* 使用 `.get('蛋白质', 0)` 来尝试从字典中获取“蛋白质”的值。如果该值不存在，则返回0。
* 通过将每100克的蛋白质含量与食物的实际数量和服务的份数相乘，我们可以得到这种食物对总蛋白质的贡献。
</code></pre>
<ol start="5">
<li><strong>计算氨基酸评分</strong>:</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> amino_acid, reference_score <span class="keyword">in</span> reference_amino_acids.items():</span><br></pre></td></tr></table></figure>
<p>这里遍历一个叫做 <code>reference_amino_acids</code> 的字典，它应该包含各种氨基酸及其参考评分。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> amino_acid <span class="keyword">in</span> nutrient_content_per_100g[food]:</span><br><span class="line">    amino_acid_content = nutrient_content_per_100g[food][amino_acid]</span><br><span class="line">    score = <span class="built_in">min</span>((amino_acid_content / reference_score), <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>* 首先检查当前食物中是否含有特定的氨基酸。
* 如果含有，就获取该氨基酸的含量，并计算其评分。评分为氨基酸含量与参考评分的比值，但不会超过1。
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total_amino_acid_scores[amino_acid] = total_amino_acid_scores.get(amino_acid, <span class="number">0</span>) + score * (amount / <span class="number">100</span>) * servings</span><br></pre></td></tr></table></figure>
<pre><code>* 更新 `total_amino_acid_scores` 字典中当前氨基酸的评分总和。
</code></pre>
<ol start="6">
<li><strong>计算总氨基酸评分</strong>:</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total_aas_score = <span class="built_in">sum</span>(total_amino_acid_scores.values()) / <span class="built_in">len</span>(reference_amino_acids)</span><br></pre></td></tr></table></figure>
<pre><code>* 将 `total_amino_acid_scores` 字典中所有值相加，得到所有氨基酸评分的总和。
* 然后将这个总和除以参考氨基酸的数量，得到平均的氨基酸评分，即“总氨基酸评分”。
</code></pre>
<ol start="7">
<li><strong>输出结果</strong>:</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;总氨基酸评分：&quot;</span>, total_aas_score)</span><br></pre></td></tr></table></figure>
<p>打印出计算得到的“总氨基酸评分”。</p>
<p>总的来说，这段代码的目的是为了评估一个食谱中食物的营养价值，特别是蛋白质和氨基酸的含量及评分。</p>
]]></content>
  </entry>
  <entry>
    <title>线性规划的基本形式与求解</title>
    <url>/2024/07/02/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BD%A2%E5%BC%8F%E4%B8%8E%E6%B1%82%E8%A7%A3/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
